using System;
using System.Collections.Generic;
using System.Linq;
using RedChess.ChessCommon;
using RedChess.ChessCommon.Enumerations;
using Redchess.Engine.Interfaces;
using Redchess.Engine.Structures;

namespace Redchess.Engine.Pieces.Abstract
{
    internal abstract class Piece : IPiece
    {
        private readonly static int s_parallelism = Environment.ProcessorCount;
        private readonly PieceType m_pieceType;
        private readonly PieceColor m_color;
        private readonly Square m_position;

        protected Piece(Location loc, PieceType typeOfPiece)
        {
            m_pieceType = typeOfPiece;
            m_color = typeOfPiece.Color();
            m_position = new Square(loc);
        }

        public PieceColor Color
        {
            get { return m_color; }
        }

        public PieceType Type
        {
            get { return m_pieceType; }
        }

        public override string ToString()
        {
            return String.Format("{0} {1}", base.ToString(), Position.Location);
        }

        public Square Position { get { return m_position; } }
        public abstract IEnumerable<Location> ReachableSquares(IBoardExtended game);

        /// <summary>
        /// Should never be called to check whether a given move is valid. Use ValidateMove() in Board instead.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<Location> ValidMoves(IBoardExtended game)
        {
            return ReachableSquares(game).AsParallel().WithDegreeOfParallelism(s_parallelism).Where(s => game.ValidateMoveForCheck(this, s));
        }

        public virtual IEnumerable<Location> AttackedSquares(IBoardExtended game)
        {
            return ReachableSquares(game);
        }

        protected internal IEnumerable<Location> ReachableSquares(IEnumerable<Vector2> moveSet, IBoardExtended game)
        {
            /* This is the base implementation of ReachableSquares. It assumes that for all pieces, reachable squares can be generated by iterating
			 * over a set of vectors until the edge of the board or another piece is hit. For Kings and Knights, the set of vectors is only applied once. */

            var enemyPieces = game.Pieces(~Color);
            var ownPieces = game.Pieces(Color);

            foreach (var moveVector in moveSet)
            {
                Square generatedSquare = Position;
                while (!generatedSquare.Equals(Square.InvalidSquare))
                {
                    generatedSquare = new Square(generatedSquare.X + moveVector.X, generatedSquare.Y + moveVector.Y);

                    if (generatedSquare.Equals(Square.InvalidSquare))
                        break; // Edge of board

                    if (enemyPieces.IsOccupied(generatedSquare.Location))
                    {
                        yield return generatedSquare.Location;
                        break; // Enemy piece (takeable). 

                        /* Kings aren't takeable, but it's impossible for the enemy king to be takeable at the start of a turn,
						   as that would mean that in the previous turn the opponent left their king in check. */
                    }

                    if (ownPieces.IsOccupied(generatedSquare.Location))
                    {
                        break; // Friendly piece, can't move here
                    }

                    yield return generatedSquare.Location;

                    if (m_pieceType.IsOfType(PieceType.King) || m_pieceType.IsOfType(PieceType.Knight))
                    {
                        break; // Kings and Knights only get one application of their move in each direction
                    }
                }
            }
        }
    }
}