using System;
using System.Collections.Generic;
using System.Linq;
using RedChess.ChessCommon;
using RedChess.ChessCommon.Enumerations;
using Redchess.Engine.Interfaces;
using Redchess.Engine.Structures;

namespace Redchess.Engine.Pieces.Abstract
{
    internal abstract class Piece : IPiece
    {
        private static readonly int s_parallelism = Environment.ProcessorCount;
        private readonly PieceType m_pieceType;
        private readonly PieceColor m_color;

        protected Piece(Location loc, PieceType typeOfPiece)
        {
            m_pieceType = typeOfPiece;
            m_color = typeOfPiece.Color();
            Position = new Square(loc);
        }

        public PieceColor Color => m_color;

        public PieceType Type => m_pieceType;

        public override string ToString() => $"{base.ToString()} {Position.Location}";

        public override int GetHashCode()
        {
            return (int) m_color + 10*(int) m_pieceType + 10000*(int) Position.Location;
        }

        public Square Position { get; }

        public abstract IEnumerable<Location> ReachableSquares(IBoardExtended game);

        /// <summary>
        /// Should never be called to check whether a given move is valid. Use ValidateMove() in Board instead.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<Location> ValidMoves(IBoardExtended game)
        {
            return ReachableSquares(game).AsParallel().WithDegreeOfParallelism(s_parallelism).Where(s => game.ValidateMoveForCheck(this, s));
        }

        public virtual IEnumerable<Location> AttackedSquares(IBoardExtended game)
        {
            return ReachableSquares(game);
        }

        protected internal IEnumerable<Location> ReachableSquares(IEnumerable<Vector2> moveSet, IBoardExtended game)
        {
            /* This is the base implementation of ReachableSquares. It assumes that for all pieces, reachable squares can be generated by iterating
			 * over a set of vectors until the edge of the board or another piece is hit. For Kings and Knights, the set of vectors is only applied once. */

            var enemyPieces = game.Pieces(~Color);
            var ownPieces = game.Pieces(Color);

            foreach (var moveVector in moveSet)
            {
                Square generatedSquare = Position;

                while (true)
                {
                    var newX = generatedSquare.X + moveVector.X;
                    if (newX < 0 || newX > 7)
                        break;
                    var newY = generatedSquare.Y + moveVector.Y;
                    if (newY < 0 || newY > 7)
                        break;

                    generatedSquare = new Square(newX, newY);

                    if (enemyPieces.IsOccupied(generatedSquare.Location))
                    {
                        yield return generatedSquare.Location;
                        break; // Enemy piece (takeable). 

                        /* Kings aren't takeable, but it's impossible for the enemy king to be takeable at the start of a turn,
						   as that would mean that in the previous turn the opponent left their king in check. */
                    }

                    if (ownPieces.IsOccupied(generatedSquare.Location))
                    {
                        break; // Friendly piece, can't move here
                    }

                    yield return generatedSquare.Location;

                    if (m_pieceType.IsOfType(PieceType.King) || m_pieceType.IsOfType(PieceType.Knight))
                    {
                        break; // Kings and Knights only get one application of their move in each direction
                    }
                }
            }
        }
    }
}