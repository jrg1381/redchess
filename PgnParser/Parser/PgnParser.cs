//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.1 H:\\Work\\redchess\\PgnParser\\Pgn.g 2015-03-02 17:21:42

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  Redchess.Pgn 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.1")]
[System.CLSCompliant(false)]
public partial class PgnParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BLACK", "BLOCK_COMMENT", "CAPTURE", "CASTLE_KINGSIDE", "CASTLE_QUEENSIDE", "CHECK", "COLUMN", "DATE", "EVENT", "GAME_RESULT", "GAME_RESULT_END_OF_MOVETEXT", "INTEGER", "LEFT_BRACKET", "LEFT_CURLY_BRACKET", "LEFT_TAG", "LINE_COMMENT", "MATE", "MOVE_ANALYSIS", "MOVE_LABEL", "NO_MOVE", "NUMERIC_ANNOTATION_GLYPH", "PIECE_SYMBOL", "PIECE_TO_SQUARE", "PROMOTES_TO", "PROMOTES_TO_PIECE", "QUOTE", "QUOTED_STRING", "RESULT", "RIGHT_BRACKET", "RIGHT_CURLY_BRACKET", "RIGHT_TAG", "ROUND", "ROW", "SITE", "SQUARE", "TAG_NAME", "TAKES", "UNAMBIGUOUS_PIECE_WITH_COLUMN", "UNAMBIGUOUS_PIECE_WITH_ROW", "UNAMBIGUOUS_PIECE_WITH_ROW_AND_COLUMN", "WHITE", "WS"
	};
	public const int EOF=-1;
	public const int BLACK=4;
	public const int BLOCK_COMMENT=5;
	public const int CAPTURE=6;
	public const int CASTLE_KINGSIDE=7;
	public const int CASTLE_QUEENSIDE=8;
	public const int CHECK=9;
	public const int COLUMN=10;
	public const int DATE=11;
	public const int EVENT=12;
	public const int GAME_RESULT=13;
	public const int GAME_RESULT_END_OF_MOVETEXT=14;
	public const int INTEGER=15;
	public const int LEFT_BRACKET=16;
	public const int LEFT_CURLY_BRACKET=17;
	public const int LEFT_TAG=18;
	public const int LINE_COMMENT=19;
	public const int MATE=20;
	public const int MOVE_ANALYSIS=21;
	public const int MOVE_LABEL=22;
	public const int NO_MOVE=23;
	public const int NUMERIC_ANNOTATION_GLYPH=24;
	public const int PIECE_SYMBOL=25;
	public const int PIECE_TO_SQUARE=26;
	public const int PROMOTES_TO=27;
	public const int PROMOTES_TO_PIECE=28;
	public const int QUOTE=29;
	public const int QUOTED_STRING=30;
	public const int RESULT=31;
	public const int RIGHT_BRACKET=32;
	public const int RIGHT_CURLY_BRACKET=33;
	public const int RIGHT_TAG=34;
	public const int ROUND=35;
	public const int ROW=36;
	public const int SITE=37;
	public const int SQUARE=38;
	public const int TAG_NAME=39;
	public const int TAKES=40;
	public const int UNAMBIGUOUS_PIECE_WITH_COLUMN=41;
	public const int UNAMBIGUOUS_PIECE_WITH_ROW=42;
	public const int UNAMBIGUOUS_PIECE_WITH_ROW_AND_COLUMN=43;
	public const int WHITE=44;
	public const int WS=45;

	public PgnParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public PgnParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return PgnParser.tokenNames; } }
	public override string GrammarFileName { get { return "H:\\Work\\redchess\\PgnParser\\Pgn.g"; } }


		private int m_variantDepth = 0;
		public bool PlayGame;
	    private static char[] c_doubleQuote = new [] { '"' }; 

		private Dictionary<string,string> m_optionalTags = new Dictionary<string,string>();
		public IDictionary<string,string> OptionalTags { get { return m_optionalTags; } }

		public string Event { get; private set; }
		public string Site { get; private set; }
		public string Date { get; private set; }
		public string Round { get; private set; }
		public string Black { get; private set; }
		public string White { get; private set; }
		public string Result { get; private set; }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_parse();
	partial void LeaveRule_parse();
	// $ANTLR start "parse"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:99:8: public parse : document ;
	[GrammarRule("parse")]
	public void parse()
	{
		EnterRule_parse();
		EnterRule("parse", 1);
		TraceIn("parse", 1);
		try { DebugEnterRule(GrammarFileName, "parse");
		DebugLocation(99, 24);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:99:14: ( document )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:99:16: document
			{
			DebugLocation(99, 16);
			PushFollow(Follow._document_in_parse660);
			document();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parse", 1);
			LeaveRule("parse", 1);
			LeaveRule_parse();
		}
		DebugLocation(99, 24);
		} finally { DebugExitRule(GrammarFileName, "parse"); }
		return;

	}
	// $ANTLR end "parse"

	partial void EnterRule_parseTag();
	partial void LeaveRule_parseTag();
	// $ANTLR start "parseTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:100:8: public parseTag : ( compulsoryTag | optionalTag );
	[GrammarRule("parseTag")]
	public void parseTag()
	{
		EnterRule_parseTag();
		EnterRule("parseTag", 2);
		TraceIn("parseTag", 2);
		try { DebugEnterRule(GrammarFileName, "parseTag");
		DebugLocation(100, 46);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:100:17: ( compulsoryTag | optionalTag )
			int alt1=2;
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1==LEFT_TAG))
			{
				int LA1_2 = input.LA(2);

				if ((LA1_2==BLACK||(LA1_2>=DATE && LA1_2<=EVENT)||LA1_2==RESULT||LA1_2==ROUND||LA1_2==SITE||LA1_2==WHITE))
				{
					alt1 = 1;
				}
				else if ((LA1_2==TAG_NAME))
				{
					alt1 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:100:19: compulsoryTag
				{
				DebugLocation(100, 19);
				PushFollow(Follow._compulsoryTag_in_parseTag670);
				compulsoryTag();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:100:35: optionalTag
				{
				DebugLocation(100, 35);
				PushFollow(Follow._optionalTag_in_parseTag674);
				optionalTag();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parseTag", 2);
			LeaveRule("parseTag", 2);
			LeaveRule_parseTag();
		}
		DebugLocation(100, 46);
		} finally { DebugExitRule(GrammarFileName, "parseTag"); }
		return;

	}
	// $ANTLR end "parseTag"

	partial void EnterRule_document();
	partial void LeaveRule_document();
	// $ANTLR start "document"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:102:1: document : gameList EOF ;
	[GrammarRule("document")]
	private void document()
	{
		EnterRule_document();
		EnterRule("document", 3);
		TraceIn("document", 3);
		try { DebugEnterRule(GrammarFileName, "document");
		DebugLocation(102, 24);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:102:10: ( gameList EOF )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:102:12: gameList EOF
			{
			DebugLocation(102, 12);
			PushFollow(Follow._gameList_in_document683);
			gameList();
			PopFollow();

			DebugLocation(102, 21);
			Match(input,EOF,Follow._EOF_in_document685); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("document", 3);
			LeaveRule("document", 3);
			LeaveRule_document();
		}
		DebugLocation(102, 24);
		} finally { DebugExitRule(GrammarFileName, "document"); }
		return;

	}
	// $ANTLR end "document"

	partial void EnterRule_gameList();
	partial void LeaveRule_gameList();
	// $ANTLR start "gameList"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:104:1: gameList : ( game )+ ;
	[GrammarRule("gameList")]
	private void gameList()
	{
		EnterRule_gameList();
		EnterRule("gameList", 4);
		TraceIn("gameList", 4);
		try { DebugEnterRule(GrammarFileName, "gameList");
		DebugLocation(104, 17);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:104:10: ( ( game )+ )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:104:12: ( game )+
			{
			DebugLocation(104, 12);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:104:12: ( game )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==LEFT_TAG))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:104:12: game
					{
					DebugLocation(104, 12);
					PushFollow(Follow._game_in_gameList694);
					game();
					PopFollow();


					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("gameList", 4);
			LeaveRule("gameList", 4);
			LeaveRule_gameList();
		}
		DebugLocation(104, 17);
		} finally { DebugExitRule(GrammarFileName, "gameList"); }
		return;

	}
	// $ANTLR end "gameList"

	partial void EnterRule_generalTagList();
	partial void LeaveRule_generalTagList();
	// $ANTLR start "generalTagList"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:1: generalTagList : ( optionalTag | compulsoryTag ) ( ( WS )* ( optionalTag | compulsoryTag ) )* ;
	[GrammarRule("generalTagList")]
	private void generalTagList()
	{
		EnterRule_generalTagList();
		EnterRule("generalTagList", 5);
		TraceIn("generalTagList", 5);
		try { DebugEnterRule(GrammarFileName, "generalTagList");
		DebugLocation(107, 80);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:16: ( ( optionalTag | compulsoryTag ) ( ( WS )* ( optionalTag | compulsoryTag ) )* )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:18: ( optionalTag | compulsoryTag ) ( ( WS )* ( optionalTag | compulsoryTag ) )*
			{
			DebugLocation(107, 18);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:18: ( optionalTag | compulsoryTag )
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==LEFT_TAG))
			{
				int LA3_2 = input.LA(2);

				if ((LA3_2==BLACK||(LA3_2>=DATE && LA3_2<=EVENT)||LA3_2==RESULT||LA3_2==ROUND||LA3_2==SITE||LA3_2==WHITE))
				{
					alt3 = 2;
				}
				else if ((LA3_2==TAG_NAME))
				{
					alt3 = 1;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:19: optionalTag
				{
				DebugLocation(107, 19);
				PushFollow(Follow._optionalTag_in_generalTagList706);
				optionalTag();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:31: compulsoryTag
				{
				DebugLocation(107, 31);
				PushFollow(Follow._compulsoryTag_in_generalTagList708);
				compulsoryTag();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(107, 46);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:46: ( ( WS )* ( optionalTag | compulsoryTag ) )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				try
				{
					alt6 = dfa6.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:47: ( WS )* ( optionalTag | compulsoryTag )
					{
					DebugLocation(107, 47);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:47: ( WS )*
					try { DebugEnterSubRule(4);
					while (true)
					{
						int alt4=2;
						try { DebugEnterDecision(4, false);
						int LA4_1 = input.LA(1);

						if ((LA4_1==WS))
						{
							alt4 = 1;
						}


						} finally { DebugExitDecision(4); }
						switch ( alt4 )
						{
						case 1:
							DebugEnterAlt(1);
							// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:47: WS
							{
							DebugLocation(107, 47);
							Match(input,WS,Follow._WS_in_generalTagList712); 

							}
							break;

						default:
							goto loop4;
						}
					}

					loop4:
						;

					} finally { DebugExitSubRule(4); }

					DebugLocation(107, 51);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:51: ( optionalTag | compulsoryTag )
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1==LEFT_TAG))
					{
						int LA5_2 = input.LA(2);

						if ((LA5_2==BLACK||(LA5_2>=DATE && LA5_2<=EVENT)||LA5_2==RESULT||LA5_2==ROUND||LA5_2==SITE||LA5_2==WHITE))
						{
							alt5 = 2;
						}
						else if ((LA5_2==TAG_NAME))
						{
							alt5 = 1;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 5, 1, input, 2);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:52: optionalTag
						{
						DebugLocation(107, 52);
						PushFollow(Follow._optionalTag_in_generalTagList716);
						optionalTag();
						PopFollow();


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// H:\\Work\\redchess\\PgnParser\\Pgn.g:107:64: compulsoryTag
						{
						DebugLocation(107, 64);
						PushFollow(Follow._compulsoryTag_in_generalTagList718);
						compulsoryTag();
						PopFollow();


						}
						break;

					}
					} finally { DebugExitSubRule(5); }


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("generalTagList", 5);
			LeaveRule("generalTagList", 5);
			LeaveRule_generalTagList();
		}
		DebugLocation(107, 80);
		} finally { DebugExitRule(GrammarFileName, "generalTagList"); }
		return;

	}
	// $ANTLR end "generalTagList"

	partial void EnterRule_game();
	partial void LeaveRule_game();
	// $ANTLR start "game"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:1: game : generalTagList ( WS )+ ( moveList )? ( WS )* ( GAME_RESULT_END_OF_MOVETEXT )? ( WS )* ;
	[GrammarRule("game")]
	private void game()
	{
		EnterRule_game();
		EnterRule("game", 6);
		TraceIn("game", 6);
		try { DebugEnterRule(GrammarFileName, "game");
		DebugLocation(109, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:6: ( generalTagList ( WS )+ ( moveList )? ( WS )* ( GAME_RESULT_END_OF_MOVETEXT )? ( WS )* )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:8: generalTagList ( WS )+ ( moveList )? ( WS )* ( GAME_RESULT_END_OF_MOVETEXT )? ( WS )*
			{
			DebugLocation(109, 8);
			PushFollow(Follow._generalTagList_in_game730);
			generalTagList();
			PopFollow();

			DebugLocation(109, 23);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:23: ( WS )+
			int cnt7=0;
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==WS))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:23: WS
					{
					DebugLocation(109, 23);
					Match(input,WS,Follow._WS_in_game732); 

					}
					break;

				default:
					if (cnt7 >= 1)
						goto loop7;

					EarlyExitException eee7 = new EarlyExitException( 7, input );
					DebugRecognitionException(eee7);
					throw eee7;
				}
				cnt7++;
			}
			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(109, 27);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:27: ( moveList )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==MOVE_LABEL))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:28: moveList
				{
				DebugLocation(109, 28);
				PushFollow(Follow._moveList_in_game736);
				moveList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(109, 39);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:39: ( WS )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==WS))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:39: WS
					{
					DebugLocation(109, 39);
					Match(input,WS,Follow._WS_in_game740); 

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(109, 43);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:43: ( GAME_RESULT_END_OF_MOVETEXT )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==GAME_RESULT_END_OF_MOVETEXT))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:43: GAME_RESULT_END_OF_MOVETEXT
				{
				DebugLocation(109, 43);
				Match(input,GAME_RESULT_END_OF_MOVETEXT,Follow._GAME_RESULT_END_OF_MOVETEXT_in_game743); 

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(109, 72);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:72: ( WS )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==WS))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:109:72: WS
					{
					DebugLocation(109, 72);
					Match(input,WS,Follow._WS_in_game746); 

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(110, 1);

				if(PlayGame)
				{
					m_processor.ResetGame();
					m_optionalTags.Clear();
				}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("game", 6);
			LeaveRule("game", 6);
			LeaveRule_game();
		}
		DebugLocation(116, 1);
		} finally { DebugExitRule(GrammarFileName, "game"); }
		return;

	}
	// $ANTLR end "game"

	partial void EnterRule_annotation();
	partial void LeaveRule_annotation();
	// $ANTLR start "annotation"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:118:1: annotation : ( blockComment | variantLine ) ;
	[GrammarRule("annotation")]
	private void annotation()
	{
		EnterRule_annotation();
		EnterRule("annotation", 7);
		TraceIn("annotation", 7);
		try { DebugEnterRule(GrammarFileName, "annotation");
		DebugLocation(118, 42);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:118:12: ( ( blockComment | variantLine ) )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:118:14: ( blockComment | variantLine )
			{
			DebugLocation(118, 14);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:118:14: ( blockComment | variantLine )
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==BLOCK_COMMENT))
			{
				alt12 = 1;
			}
			else if ((LA12_1==LEFT_BRACKET))
			{
				alt12 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:118:15: blockComment
				{
				DebugLocation(118, 15);
				PushFollow(Follow._blockComment_in_annotation758);
				blockComment();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:118:30: variantLine
				{
				DebugLocation(118, 30);
				PushFollow(Follow._variantLine_in_annotation762);
				variantLine();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(12); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("annotation", 7);
			LeaveRule("annotation", 7);
			LeaveRule_annotation();
		}
		DebugLocation(118, 42);
		} finally { DebugExitRule(GrammarFileName, "annotation"); }
		return;

	}
	// $ANTLR end "annotation"

	partial void EnterRule_annotationList();
	partial void LeaveRule_annotationList();
	// $ANTLR start "annotationList"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:119:1: annotationList : annotation ( ( WS )+ annotation )* ;
	[GrammarRule("annotationList")]
	private void annotationList()
	{
		EnterRule_annotationList();
		EnterRule("annotationList", 8);
		TraceIn("annotationList", 8);
		try { DebugEnterRule(GrammarFileName, "annotationList");
		DebugLocation(119, 46);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:119:16: ( annotation ( ( WS )+ annotation )* )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:119:18: annotation ( ( WS )+ annotation )*
			{
			DebugLocation(119, 18);
			PushFollow(Follow._annotation_in_annotationList771);
			annotation();
			PopFollow();

			DebugLocation(119, 29);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:119:29: ( ( WS )+ annotation )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				try
				{
					alt14 = dfa14.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:119:30: ( WS )+ annotation
					{
					DebugLocation(119, 30);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:119:30: ( WS )+
					int cnt13=0;
					try { DebugEnterSubRule(13);
					while (true)
					{
						int alt13=2;
						try { DebugEnterDecision(13, false);
						int LA13_1 = input.LA(1);

						if ((LA13_1==WS))
						{
							alt13 = 1;
						}


						} finally { DebugExitDecision(13); }
						switch (alt13)
						{
						case 1:
							DebugEnterAlt(1);
							// H:\\Work\\redchess\\PgnParser\\Pgn.g:119:30: WS
							{
							DebugLocation(119, 30);
							Match(input,WS,Follow._WS_in_annotationList774); 

							}
							break;

						default:
							if (cnt13 >= 1)
								goto loop13;

							EarlyExitException eee13 = new EarlyExitException( 13, input );
							DebugRecognitionException(eee13);
							throw eee13;
						}
						cnt13++;
					}
					loop13:
						;

					} finally { DebugExitSubRule(13); }

					DebugLocation(119, 34);
					PushFollow(Follow._annotation_in_annotationList777);
					annotation();
					PopFollow();


					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("annotationList", 8);
			LeaveRule("annotationList", 8);
			LeaveRule_annotationList();
		}
		DebugLocation(119, 46);
		} finally { DebugExitRule(GrammarFileName, "annotationList"); }
		return;

	}
	// $ANTLR end "annotationList"

	partial void EnterRule_individualMove();
	partial void LeaveRule_individualMove();
	// $ANTLR start "individualMove"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:1: individualMove : foo= ( PIECE_TO_SQUARE | CAPTURE | CASTLE_KINGSIDE | CASTLE_QUEENSIDE ) (promote= PROMOTES_TO_PIECE )? (checkormate= CHECK |checkormate= MATE )? ( MOVE_ANALYSIS )? ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )? ( ( WS )+ annotationList )? ;
	[GrammarRule("individualMove")]
	private void individualMove()
	{
		EnterRule_individualMove();
		EnterRule("individualMove", 9);
		TraceIn("individualMove", 9);
		IToken foo = default(IToken);
		IToken promote = default(IToken);
		IToken checkormate = default(IToken);
		IToken annotation_glyph = default(IToken);

		try { DebugEnterRule(GrammarFileName, "individualMove");
		DebugLocation(120, 2);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:16: (foo= ( PIECE_TO_SQUARE | CAPTURE | CASTLE_KINGSIDE | CASTLE_QUEENSIDE ) (promote= PROMOTES_TO_PIECE )? (checkormate= CHECK |checkormate= MATE )? ( MOVE_ANALYSIS )? ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )? ( ( WS )+ annotationList )? )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:18: foo= ( PIECE_TO_SQUARE | CAPTURE | CASTLE_KINGSIDE | CASTLE_QUEENSIDE ) (promote= PROMOTES_TO_PIECE )? (checkormate= CHECK |checkormate= MATE )? ( MOVE_ANALYSIS )? ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )? ( ( WS )+ annotationList )?
			{
			DebugLocation(120, 21);

			foo=(IToken)input.LT(1);
			if ((input.LA(1)>=CAPTURE && input.LA(1)<=CASTLE_QUEENSIDE)||input.LA(1)==PIECE_TO_SQUARE)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(120, 84);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:84: (promote= PROMOTES_TO_PIECE )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==PROMOTES_TO_PIECE))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:85: promote= PROMOTES_TO_PIECE
				{
				DebugLocation(120, 92);
				promote=(IToken)Match(input,PROMOTES_TO_PIECE,Follow._PROMOTES_TO_PIECE_in_individualMove805); 

				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(120, 113);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:113: (checkormate= CHECK |checkormate= MATE )?
			int alt16=3;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==CHECK))
			{
				alt16 = 1;
			}
			else if ((LA16_1==MATE))
			{
				alt16 = 2;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:114: checkormate= CHECK
				{
				DebugLocation(120, 125);
				checkormate=(IToken)Match(input,CHECK,Follow._CHECK_in_individualMove812); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:132: checkormate= MATE
				{
				DebugLocation(120, 143);
				checkormate=(IToken)Match(input,MATE,Follow._MATE_in_individualMove816); 

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(120, 151);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:151: ( MOVE_ANALYSIS )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==MOVE_ANALYSIS))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:151: MOVE_ANALYSIS
				{
				DebugLocation(120, 151);
				Match(input,MOVE_ANALYSIS,Follow._MOVE_ANALYSIS_in_individualMove820); 

				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(120, 166);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:166: ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			try
			{
				alt19 = dfa19.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:167: ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH
				{
				DebugLocation(120, 167);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:167: ( WS )+
				int cnt18=0;
				try { DebugEnterSubRule(18);
				while (true)
				{
					int alt18=2;
					try { DebugEnterDecision(18, false);
					int LA18_1 = input.LA(1);

					if ((LA18_1==WS))
					{
						alt18 = 1;
					}


					} finally { DebugExitDecision(18); }
					switch (alt18)
					{
					case 1:
						DebugEnterAlt(1);
						// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:167: WS
						{
						DebugLocation(120, 167);
						Match(input,WS,Follow._WS_in_individualMove824); 

						}
						break;

					default:
						if (cnt18 >= 1)
							goto loop18;

						EarlyExitException eee18 = new EarlyExitException( 18, input );
						DebugRecognitionException(eee18);
						throw eee18;
					}
					cnt18++;
				}
				loop18:
					;

				} finally { DebugExitSubRule(18); }

				DebugLocation(120, 187);
				annotation_glyph=(IToken)Match(input,NUMERIC_ANNOTATION_GLYPH,Follow._NUMERIC_ANNOTATION_GLYPH_in_individualMove829); 

				}
				break;

			}
			} finally { DebugExitSubRule(19); }

			DebugLocation(120, 215);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:215: ( ( WS )+ annotationList )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			try
			{
				alt21 = dfa21.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:216: ( WS )+ annotationList
				{
				DebugLocation(120, 216);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:216: ( WS )+
				int cnt20=0;
				try { DebugEnterSubRule(20);
				while (true)
				{
					int alt20=2;
					try { DebugEnterDecision(20, false);
					int LA20_1 = input.LA(1);

					if ((LA20_1==WS))
					{
						alt20 = 1;
					}


					} finally { DebugExitDecision(20); }
					switch (alt20)
					{
					case 1:
						DebugEnterAlt(1);
						// H:\\Work\\redchess\\PgnParser\\Pgn.g:120:216: WS
						{
						DebugLocation(120, 216);
						Match(input,WS,Follow._WS_in_individualMove834); 

						}
						break;

					default:
						if (cnt20 >= 1)
							goto loop20;

						EarlyExitException eee20 = new EarlyExitException( 20, input );
						DebugRecognitionException(eee20);
						throw eee20;
					}
					cnt20++;
				}
				loop20:
					;

				} finally { DebugExitSubRule(20); }

				DebugLocation(120, 220);
				PushFollow(Follow._annotationList_in_individualMove837);
				annotationList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(21); }

			DebugLocation(121, 1);

				if(PlayGame && m_variantDepth == 0)
					m_processor.ProcessMove(foo, promote == null ? "" : promote.Text, checkormate == null ? "" : checkormate.Text, annotation_glyph == null ? "" : annotation_glyph.Text);


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("individualMove", 9);
			LeaveRule("individualMove", 9);
			LeaveRule_individualMove();
		}
		DebugLocation(124, 2);
		} finally { DebugExitRule(GrammarFileName, "individualMove"); }
		return;

	}
	// $ANTLR end "individualMove"

	partial void EnterRule_moveList();
	partial void LeaveRule_moveList();
	// $ANTLR start "moveList"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:127:1: moveList : move ( ( WS )+ move )* ;
	[GrammarRule("moveList")]
	private void moveList()
	{
		EnterRule_moveList();
		EnterRule("moveList", 10);
		TraceIn("moveList", 10);
		try { DebugEnterRule(GrammarFileName, "moveList");
		DebugLocation(127, 28);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:127:10: ( move ( ( WS )+ move )* )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:127:12: move ( ( WS )+ move )*
			{
			DebugLocation(127, 12);
			PushFollow(Follow._move_in_moveList851);
			move();
			PopFollow();

			DebugLocation(127, 17);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:127:17: ( ( WS )+ move )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				try
				{
					alt23 = dfa23.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:127:18: ( WS )+ move
					{
					DebugLocation(127, 18);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:127:18: ( WS )+
					int cnt22=0;
					try { DebugEnterSubRule(22);
					while (true)
					{
						int alt22=2;
						try { DebugEnterDecision(22, false);
						int LA22_1 = input.LA(1);

						if ((LA22_1==WS))
						{
							alt22 = 1;
						}


						} finally { DebugExitDecision(22); }
						switch (alt22)
						{
						case 1:
							DebugEnterAlt(1);
							// H:\\Work\\redchess\\PgnParser\\Pgn.g:127:18: WS
							{
							DebugLocation(127, 18);
							Match(input,WS,Follow._WS_in_moveList854); 

							}
							break;

						default:
							if (cnt22 >= 1)
								goto loop22;

							EarlyExitException eee22 = new EarlyExitException( 22, input );
							DebugRecognitionException(eee22);
							throw eee22;
						}
						cnt22++;
					}
					loop22:
						;

					} finally { DebugExitSubRule(22); }

					DebugLocation(127, 22);
					PushFollow(Follow._move_in_moveList857);
					move();
					PopFollow();


					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("moveList", 10);
			LeaveRule("moveList", 10);
			LeaveRule_moveList();
		}
		DebugLocation(127, 28);
		} finally { DebugExitRule(GrammarFileName, "moveList"); }
		return;

	}
	// $ANTLR end "moveList"

	partial void EnterRule_move();
	partial void LeaveRule_move();
	// $ANTLR start "move"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:1: move : MOVE_LABEL ( WS )* ( NO_MOVE ( WS )* )? individualMove ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )? ;
	[GrammarRule("move")]
	private void move()
	{
		EnterRule_move();
		EnterRule("move", 11);
		TraceIn("move", 11);
		try { DebugEnterRule(GrammarFileName, "move");
		DebugLocation(129, 105);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:6: ( MOVE_LABEL ( WS )* ( NO_MOVE ( WS )* )? individualMove ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )? )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:8: MOVE_LABEL ( WS )* ( NO_MOVE ( WS )* )? individualMove ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )?
			{
			DebugLocation(129, 8);
			Match(input,MOVE_LABEL,Follow._MOVE_LABEL_in_move868); 
			DebugLocation(129, 19);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:19: ( WS )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==WS))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:19: WS
					{
					DebugLocation(129, 19);
					Match(input,WS,Follow._WS_in_move870); 

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }

			DebugLocation(129, 23);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:23: ( NO_MOVE ( WS )* )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_1 = input.LA(1);

			if ((LA26_1==NO_MOVE))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:24: NO_MOVE ( WS )*
				{
				DebugLocation(129, 24);
				Match(input,NO_MOVE,Follow._NO_MOVE_in_move874); 
				DebugLocation(129, 32);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:32: ( WS )*
				try { DebugEnterSubRule(25);
				while (true)
				{
					int alt25=2;
					try { DebugEnterDecision(25, false);
					int LA25_1 = input.LA(1);

					if ((LA25_1==WS))
					{
						alt25 = 1;
					}


					} finally { DebugExitDecision(25); }
					switch ( alt25 )
					{
					case 1:
						DebugEnterAlt(1);
						// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:32: WS
						{
						DebugLocation(129, 32);
						Match(input,WS,Follow._WS_in_move876); 

						}
						break;

					default:
						goto loop25;
					}
				}

				loop25:
					;

				} finally { DebugExitSubRule(25); }


				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(129, 38);
			PushFollow(Follow._individualMove_in_move881);
			individualMove();
			PopFollow();

			DebugLocation(129, 53);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:53: ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )?
			int alt32=2;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			try
			{
				alt32 = dfa32.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:54: ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove
				{
				DebugLocation(129, 54);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:54: ( WS )+
				int cnt27=0;
				try { DebugEnterSubRule(27);
				while (true)
				{
					int alt27=2;
					try { DebugEnterDecision(27, false);
					int LA27_1 = input.LA(1);

					if ((LA27_1==WS))
					{
						alt27 = 1;
					}


					} finally { DebugExitDecision(27); }
					switch (alt27)
					{
					case 1:
						DebugEnterAlt(1);
						// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:54: WS
						{
						DebugLocation(129, 54);
						Match(input,WS,Follow._WS_in_move884); 

						}
						break;

					default:
						if (cnt27 >= 1)
							goto loop27;

						EarlyExitException eee27 = new EarlyExitException( 27, input );
						DebugRecognitionException(eee27);
						throw eee27;
					}
					cnt27++;
				}
				loop27:
					;

				} finally { DebugExitSubRule(27); }

				DebugLocation(129, 58);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:58: ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )?
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if (((LA31_1>=MOVE_LABEL && LA31_1<=NO_MOVE)||LA31_1==WS))
				{
					alt31 = 1;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:59: ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )*
					{
					DebugLocation(129, 59);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:59: ( MOVE_LABEL )?
					int alt28=2;
					try { DebugEnterSubRule(28);
					try { DebugEnterDecision(28, false);
					int LA28_1 = input.LA(1);

					if ((LA28_1==MOVE_LABEL))
					{
						alt28 = 1;
					}
					} finally { DebugExitDecision(28); }
					switch (alt28)
					{
					case 1:
						DebugEnterAlt(1);
						// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:59: MOVE_LABEL
						{
						DebugLocation(129, 59);
						Match(input,MOVE_LABEL,Follow._MOVE_LABEL_in_move888); 

						}
						break;

					}
					} finally { DebugExitSubRule(28); }

					DebugLocation(129, 71);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:71: ( WS )*
					try { DebugEnterSubRule(29);
					while (true)
					{
						int alt29=2;
						try { DebugEnterDecision(29, false);
						int LA29_1 = input.LA(1);

						if ((LA29_1==WS))
						{
							alt29 = 1;
						}


						} finally { DebugExitDecision(29); }
						switch ( alt29 )
						{
						case 1:
							DebugEnterAlt(1);
							// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:71: WS
							{
							DebugLocation(129, 71);
							Match(input,WS,Follow._WS_in_move891); 

							}
							break;

						default:
							goto loop29;
						}
					}

					loop29:
						;

					} finally { DebugExitSubRule(29); }

					DebugLocation(129, 75);
					Match(input,NO_MOVE,Follow._NO_MOVE_in_move894); 
					DebugLocation(129, 83);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:83: ( WS )*
					try { DebugEnterSubRule(30);
					while (true)
					{
						int alt30=2;
						try { DebugEnterDecision(30, false);
						int LA30_1 = input.LA(1);

						if ((LA30_1==WS))
						{
							alt30 = 1;
						}


						} finally { DebugExitDecision(30); }
						switch ( alt30 )
						{
						case 1:
							DebugEnterAlt(1);
							// H:\\Work\\redchess\\PgnParser\\Pgn.g:129:83: WS
							{
							DebugLocation(129, 83);
							Match(input,WS,Follow._WS_in_move896); 

							}
							break;

						default:
							goto loop30;
						}
					}

					loop30:
						;

					} finally { DebugExitSubRule(30); }


					}
					break;

				}
				} finally { DebugExitSubRule(31); }

				DebugLocation(129, 89);
				PushFollow(Follow._individualMove_in_move901);
				individualMove();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(32); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("move", 11);
			LeaveRule("move", 11);
			LeaveRule_move();
		}
		DebugLocation(129, 105);
		} finally { DebugExitRule(GrammarFileName, "move"); }
		return;

	}
	// $ANTLR end "move"

	partial void EnterRule_compulsoryTag();
	partial void LeaveRule_compulsoryTag();
	// $ANTLR start "compulsoryTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:1: compulsoryTag : ( eventTag | siteTag | dateTag | roundTag | blackTag | whiteTag | resultTag ) ;
	[GrammarRule("compulsoryTag")]
	private void compulsoryTag()
	{
		EnterRule_compulsoryTag();
		EnterRule("compulsoryTag", 12);
		TraceIn("compulsoryTag", 12);
		try { DebugEnterRule(GrammarFileName, "compulsoryTag");
		DebugLocation(130, 92);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:15: ( ( eventTag | siteTag | dateTag | roundTag | blackTag | whiteTag | resultTag ) )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:17: ( eventTag | siteTag | dateTag | roundTag | blackTag | whiteTag | resultTag )
			{
			DebugLocation(130, 17);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:17: ( eventTag | siteTag | dateTag | roundTag | blackTag | whiteTag | resultTag )
			int alt33=7;
			try { DebugEnterSubRule(33);
			try { DebugEnterDecision(33, false);
			int LA33_1 = input.LA(1);

			if ((LA33_1==LEFT_TAG))
			{
				switch (input.LA(2))
				{
				case EVENT:
					{
					alt33 = 1;
					}
					break;
				case SITE:
					{
					alt33 = 2;
					}
					break;
				case DATE:
					{
					alt33 = 3;
					}
					break;
				case ROUND:
					{
					alt33 = 4;
					}
					break;
				case BLACK:
					{
					alt33 = 5;
					}
					break;
				case WHITE:
					{
					alt33 = 6;
					}
					break;
				case RESULT:
					{
					alt33 = 7;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 33, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 33, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:18: eventTag
				{
				DebugLocation(130, 18);
				PushFollow(Follow._eventTag_in_compulsoryTag912);
				eventTag();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:29: siteTag
				{
				DebugLocation(130, 29);
				PushFollow(Follow._siteTag_in_compulsoryTag916);
				siteTag();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:39: dateTag
				{
				DebugLocation(130, 39);
				PushFollow(Follow._dateTag_in_compulsoryTag920);
				dateTag();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:49: roundTag
				{
				DebugLocation(130, 49);
				PushFollow(Follow._roundTag_in_compulsoryTag924);
				roundTag();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:60: blackTag
				{
				DebugLocation(130, 60);
				PushFollow(Follow._blackTag_in_compulsoryTag928);
				blackTag();
				PopFollow();


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:71: whiteTag
				{
				DebugLocation(130, 71);
				PushFollow(Follow._whiteTag_in_compulsoryTag932);
				whiteTag();
				PopFollow();


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// H:\\Work\\redchess\\PgnParser\\Pgn.g:130:82: resultTag
				{
				DebugLocation(130, 82);
				PushFollow(Follow._resultTag_in_compulsoryTag936);
				resultTag();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(33); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("compulsoryTag", 12);
			LeaveRule("compulsoryTag", 12);
			LeaveRule_compulsoryTag();
		}
		DebugLocation(130, 92);
		} finally { DebugExitRule(GrammarFileName, "compulsoryTag"); }
		return;

	}
	// $ANTLR end "compulsoryTag"

	partial void EnterRule_blockComment();
	partial void LeaveRule_blockComment();
	// $ANTLR start "blockComment"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:132:1: blockComment : comment= BLOCK_COMMENT ;
	[GrammarRule("blockComment")]
	private void blockComment()
	{
		EnterRule_blockComment();
		EnterRule("blockComment", 13);
		TraceIn("blockComment", 13);
		IToken comment = default(IToken);

		try { DebugEnterRule(GrammarFileName, "blockComment");
		DebugLocation(132, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:132:14: (comment= BLOCK_COMMENT )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:132:16: comment= BLOCK_COMMENT
			{
			DebugLocation(132, 23);
			comment=(IToken)Match(input,BLOCK_COMMENT,Follow._BLOCK_COMMENT_in_blockComment948); 
			DebugLocation(133, 1);

				// Console.WriteLine(comment.Text);


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("blockComment", 13);
			LeaveRule("blockComment", 13);
			LeaveRule_blockComment();
		}
		DebugLocation(135, 1);
		} finally { DebugExitRule(GrammarFileName, "blockComment"); }
		return;

	}
	// $ANTLR end "blockComment"

	partial void EnterRule_enterVariant();
	partial void LeaveRule_enterVariant();
	// $ANTLR start "enterVariant"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:137:1: enterVariant : LEFT_BRACKET ;
	[GrammarRule("enterVariant")]
	private void enterVariant()
	{
		EnterRule_enterVariant();
		EnterRule("enterVariant", 14);
		TraceIn("enterVariant", 14);
		try { DebugEnterRule(GrammarFileName, "enterVariant");
		DebugLocation(137, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:137:14: ( LEFT_BRACKET )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:137:16: LEFT_BRACKET
			{
			DebugLocation(137, 16);
			Match(input,LEFT_BRACKET,Follow._LEFT_BRACKET_in_enterVariant958); 
			DebugLocation(138, 1);

				m_variantDepth++;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("enterVariant", 14);
			LeaveRule("enterVariant", 14);
			LeaveRule_enterVariant();
		}
		DebugLocation(140, 1);
		} finally { DebugExitRule(GrammarFileName, "enterVariant"); }
		return;

	}
	// $ANTLR end "enterVariant"

	partial void EnterRule_leaveVariant();
	partial void LeaveRule_leaveVariant();
	// $ANTLR start "leaveVariant"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:142:1: leaveVariant : RIGHT_BRACKET ;
	[GrammarRule("leaveVariant")]
	private void leaveVariant()
	{
		EnterRule_leaveVariant();
		EnterRule("leaveVariant", 15);
		TraceIn("leaveVariant", 15);
		try { DebugEnterRule(GrammarFileName, "leaveVariant");
		DebugLocation(142, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:142:14: ( RIGHT_BRACKET )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:142:16: RIGHT_BRACKET
			{
			DebugLocation(142, 16);
			Match(input,RIGHT_BRACKET,Follow._RIGHT_BRACKET_in_leaveVariant968); 
			DebugLocation(143, 1);

				m_variantDepth--;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("leaveVariant", 15);
			LeaveRule("leaveVariant", 15);
			LeaveRule_leaveVariant();
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "leaveVariant"); }
		return;

	}
	// $ANTLR end "leaveVariant"

	partial void EnterRule_variantLine();
	partial void LeaveRule_variantLine();
	// $ANTLR start "variantLine"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:147:1: variantLine : enterVariant ( moveList | variantLine )* ( WS )* leaveVariant ;
	[GrammarRule("variantLine")]
	private void variantLine()
	{
		EnterRule_variantLine();
		EnterRule("variantLine", 16);
		TraceIn("variantLine", 16);
		try { DebugEnterRule(GrammarFileName, "variantLine");
		DebugLocation(147, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:147:13: ( enterVariant ( moveList | variantLine )* ( WS )* leaveVariant )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:147:15: enterVariant ( moveList | variantLine )* ( WS )* leaveVariant
			{
			DebugLocation(147, 15);
			PushFollow(Follow._enterVariant_in_variantLine978);
			enterVariant();
			PopFollow();

			DebugLocation(147, 28);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:147:28: ( moveList | variantLine )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=3;
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if ((LA34_1==MOVE_LABEL))
				{
					alt34 = 1;
				}
				else if ((LA34_1==LEFT_BRACKET))
				{
					alt34 = 2;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:147:29: moveList
					{
					DebugLocation(147, 29);
					PushFollow(Follow._moveList_in_variantLine981);
					moveList();
					PopFollow();


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:147:40: variantLine
					{
					DebugLocation(147, 40);
					PushFollow(Follow._variantLine_in_variantLine985);
					variantLine();
					PopFollow();


					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }

			DebugLocation(147, 54);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:147:54: ( WS )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1==WS))
				{
					alt35 = 1;
				}


				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:147:54: WS
					{
					DebugLocation(147, 54);
					Match(input,WS,Follow._WS_in_variantLine989); 

					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }

			DebugLocation(147, 58);
			PushFollow(Follow._leaveVariant_in_variantLine992);
			leaveVariant();
			PopFollow();

			DebugLocation(148, 1);

				// Console.WriteLine(actual_text.Text);


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variantLine", 16);
			LeaveRule("variantLine", 16);
			LeaveRule_variantLine();
		}
		DebugLocation(150, 1);
		} finally { DebugExitRule(GrammarFileName, "variantLine"); }
		return;

	}
	// $ANTLR end "variantLine"

	partial void EnterRule_eventTag();
	partial void LeaveRule_eventTag();
	// $ANTLR start "eventTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:152:1: eventTag : LEFT_TAG EVENT ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("eventTag")]
	private void eventTag()
	{
		EnterRule_eventTag();
		EnterRule("eventTag", 17);
		TraceIn("eventTag", 17);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "eventTag");
		DebugLocation(152, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:152:10: ( LEFT_TAG EVENT ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:152:12: LEFT_TAG EVENT ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(152, 12);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_eventTag1002); 
			DebugLocation(152, 21);
			Match(input,EVENT,Follow._EVENT_in_eventTag1004); 
			DebugLocation(152, 27);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:152:27: ( WS )+
			int cnt36=0;
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if ((LA36_1==WS))
				{
					alt36 = 1;
				}


				} finally { DebugExitDecision(36); }
				switch (alt36)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:152:27: WS
					{
					DebugLocation(152, 27);
					Match(input,WS,Follow._WS_in_eventTag1006); 

					}
					break;

				default:
					if (cnt36 >= 1)
						goto loop36;

					EarlyExitException eee36 = new EarlyExitException( 36, input );
					DebugRecognitionException(eee36);
					throw eee36;
				}
				cnt36++;
			}
			loop36:
				;

			} finally { DebugExitSubRule(36); }

			DebugLocation(152, 34);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_eventTag1011); 
			DebugLocation(152, 49);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_eventTag1013); 
			DebugLocation(153, 1);
			 
				Event = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("eventTag", 17);
			LeaveRule("eventTag", 17);
			LeaveRule_eventTag();
		}
		DebugLocation(155, 1);
		} finally { DebugExitRule(GrammarFileName, "eventTag"); }
		return;

	}
	// $ANTLR end "eventTag"

	partial void EnterRule_siteTag();
	partial void LeaveRule_siteTag();
	// $ANTLR start "siteTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:157:1: siteTag : LEFT_TAG SITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("siteTag")]
	private void siteTag()
	{
		EnterRule_siteTag();
		EnterRule("siteTag", 18);
		TraceIn("siteTag", 18);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "siteTag");
		DebugLocation(157, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:157:9: ( LEFT_TAG SITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:157:11: LEFT_TAG SITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(157, 11);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_siteTag1024); 
			DebugLocation(157, 20);
			Match(input,SITE,Follow._SITE_in_siteTag1026); 
			DebugLocation(157, 25);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:157:25: ( WS )+
			int cnt37=0;
			try { DebugEnterSubRule(37);
			while (true)
			{
				int alt37=2;
				try { DebugEnterDecision(37, false);
				int LA37_1 = input.LA(1);

				if ((LA37_1==WS))
				{
					alt37 = 1;
				}


				} finally { DebugExitDecision(37); }
				switch (alt37)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:157:25: WS
					{
					DebugLocation(157, 25);
					Match(input,WS,Follow._WS_in_siteTag1028); 

					}
					break;

				default:
					if (cnt37 >= 1)
						goto loop37;

					EarlyExitException eee37 = new EarlyExitException( 37, input );
					DebugRecognitionException(eee37);
					throw eee37;
				}
				cnt37++;
			}
			loop37:
				;

			} finally { DebugExitSubRule(37); }

			DebugLocation(157, 32);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_siteTag1033); 
			DebugLocation(157, 47);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_siteTag1035); 
			DebugLocation(158, 1);
			 
				Site = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("siteTag", 18);
			LeaveRule("siteTag", 18);
			LeaveRule_siteTag();
		}
		DebugLocation(160, 1);
		} finally { DebugExitRule(GrammarFileName, "siteTag"); }
		return;

	}
	// $ANTLR end "siteTag"

	partial void EnterRule_dateTag();
	partial void LeaveRule_dateTag();
	// $ANTLR start "dateTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:162:1: dateTag : LEFT_TAG DATE ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("dateTag")]
	private void dateTag()
	{
		EnterRule_dateTag();
		EnterRule("dateTag", 19);
		TraceIn("dateTag", 19);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "dateTag");
		DebugLocation(162, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:162:9: ( LEFT_TAG DATE ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:162:11: LEFT_TAG DATE ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(162, 11);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_dateTag1046); 
			DebugLocation(162, 20);
			Match(input,DATE,Follow._DATE_in_dateTag1048); 
			DebugLocation(162, 25);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:162:25: ( WS )+
			int cnt38=0;
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=2;
				try { DebugEnterDecision(38, false);
				int LA38_1 = input.LA(1);

				if ((LA38_1==WS))
				{
					alt38 = 1;
				}


				} finally { DebugExitDecision(38); }
				switch (alt38)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:162:25: WS
					{
					DebugLocation(162, 25);
					Match(input,WS,Follow._WS_in_dateTag1050); 

					}
					break;

				default:
					if (cnt38 >= 1)
						goto loop38;

					EarlyExitException eee38 = new EarlyExitException( 38, input );
					DebugRecognitionException(eee38);
					throw eee38;
				}
				cnt38++;
			}
			loop38:
				;

			} finally { DebugExitSubRule(38); }

			DebugLocation(162, 32);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_dateTag1055); 
			DebugLocation(162, 47);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_dateTag1057); 
			DebugLocation(163, 1);
			 
				Date = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("dateTag", 19);
			LeaveRule("dateTag", 19);
			LeaveRule_dateTag();
		}
		DebugLocation(165, 1);
		} finally { DebugExitRule(GrammarFileName, "dateTag"); }
		return;

	}
	// $ANTLR end "dateTag"

	partial void EnterRule_roundTag();
	partial void LeaveRule_roundTag();
	// $ANTLR start "roundTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:167:1: roundTag : LEFT_TAG ROUND ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("roundTag")]
	private void roundTag()
	{
		EnterRule_roundTag();
		EnterRule("roundTag", 20);
		TraceIn("roundTag", 20);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "roundTag");
		DebugLocation(167, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:167:10: ( LEFT_TAG ROUND ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:167:12: LEFT_TAG ROUND ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(167, 12);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_roundTag1068); 
			DebugLocation(167, 21);
			Match(input,ROUND,Follow._ROUND_in_roundTag1070); 
			DebugLocation(167, 27);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:167:27: ( WS )+
			int cnt39=0;
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1==WS))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch (alt39)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:167:27: WS
					{
					DebugLocation(167, 27);
					Match(input,WS,Follow._WS_in_roundTag1072); 

					}
					break;

				default:
					if (cnt39 >= 1)
						goto loop39;

					EarlyExitException eee39 = new EarlyExitException( 39, input );
					DebugRecognitionException(eee39);
					throw eee39;
				}
				cnt39++;
			}
			loop39:
				;

			} finally { DebugExitSubRule(39); }

			DebugLocation(167, 34);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_roundTag1077); 
			DebugLocation(167, 49);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_roundTag1079); 
			DebugLocation(168, 1);
			 
				Round = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("roundTag", 20);
			LeaveRule("roundTag", 20);
			LeaveRule_roundTag();
		}
		DebugLocation(170, 1);
		} finally { DebugExitRule(GrammarFileName, "roundTag"); }
		return;

	}
	// $ANTLR end "roundTag"

	partial void EnterRule_blackTag();
	partial void LeaveRule_blackTag();
	// $ANTLR start "blackTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:172:1: blackTag : LEFT_TAG BLACK ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("blackTag")]
	private void blackTag()
	{
		EnterRule_blackTag();
		EnterRule("blackTag", 21);
		TraceIn("blackTag", 21);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "blackTag");
		DebugLocation(172, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:172:10: ( LEFT_TAG BLACK ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:172:12: LEFT_TAG BLACK ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(172, 12);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_blackTag1090); 
			DebugLocation(172, 22);
			Match(input,BLACK,Follow._BLACK_in_blackTag1093); 
			DebugLocation(172, 28);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:172:28: ( WS )+
			int cnt40=0;
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==WS))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch (alt40)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:172:28: WS
					{
					DebugLocation(172, 28);
					Match(input,WS,Follow._WS_in_blackTag1095); 

					}
					break;

				default:
					if (cnt40 >= 1)
						goto loop40;

					EarlyExitException eee40 = new EarlyExitException( 40, input );
					DebugRecognitionException(eee40);
					throw eee40;
				}
				cnt40++;
			}
			loop40:
				;

			} finally { DebugExitSubRule(40); }

			DebugLocation(172, 35);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_blackTag1100); 
			DebugLocation(172, 50);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_blackTag1102); 
			DebugLocation(173, 1);
			 
				Black = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("blackTag", 21);
			LeaveRule("blackTag", 21);
			LeaveRule_blackTag();
		}
		DebugLocation(175, 1);
		} finally { DebugExitRule(GrammarFileName, "blackTag"); }
		return;

	}
	// $ANTLR end "blackTag"

	partial void EnterRule_whiteTag();
	partial void LeaveRule_whiteTag();
	// $ANTLR start "whiteTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:177:1: whiteTag : LEFT_TAG WHITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("whiteTag")]
	private void whiteTag()
	{
		EnterRule_whiteTag();
		EnterRule("whiteTag", 22);
		TraceIn("whiteTag", 22);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "whiteTag");
		DebugLocation(177, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:177:10: ( LEFT_TAG WHITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:177:12: LEFT_TAG WHITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(177, 12);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_whiteTag1113); 
			DebugLocation(177, 21);
			Match(input,WHITE,Follow._WHITE_in_whiteTag1115); 
			DebugLocation(177, 27);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:177:27: ( WS )+
			int cnt41=0;
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=2;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==WS))
				{
					alt41 = 1;
				}


				} finally { DebugExitDecision(41); }
				switch (alt41)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:177:27: WS
					{
					DebugLocation(177, 27);
					Match(input,WS,Follow._WS_in_whiteTag1117); 

					}
					break;

				default:
					if (cnt41 >= 1)
						goto loop41;

					EarlyExitException eee41 = new EarlyExitException( 41, input );
					DebugRecognitionException(eee41);
					throw eee41;
				}
				cnt41++;
			}
			loop41:
				;

			} finally { DebugExitSubRule(41); }

			DebugLocation(177, 34);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_whiteTag1122); 
			DebugLocation(177, 49);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_whiteTag1124); 
			DebugLocation(178, 1);
			 
				White = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whiteTag", 22);
			LeaveRule("whiteTag", 22);
			LeaveRule_whiteTag();
		}
		DebugLocation(180, 1);
		} finally { DebugExitRule(GrammarFileName, "whiteTag"); }
		return;

	}
	// $ANTLR end "whiteTag"

	partial void EnterRule_resultTag();
	partial void LeaveRule_resultTag();
	// $ANTLR start "resultTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:182:1: resultTag : LEFT_TAG RESULT ( WS )+ bar= GAME_RESULT RIGHT_TAG ;
	[GrammarRule("resultTag")]
	private void resultTag()
	{
		EnterRule_resultTag();
		EnterRule("resultTag", 23);
		TraceIn("resultTag", 23);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "resultTag");
		DebugLocation(182, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:182:11: ( LEFT_TAG RESULT ( WS )+ bar= GAME_RESULT RIGHT_TAG )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:182:13: LEFT_TAG RESULT ( WS )+ bar= GAME_RESULT RIGHT_TAG
			{
			DebugLocation(182, 13);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_resultTag1135); 
			DebugLocation(182, 22);
			Match(input,RESULT,Follow._RESULT_in_resultTag1137); 
			DebugLocation(182, 29);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:182:29: ( WS )+
			int cnt42=0;
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_1 = input.LA(1);

				if ((LA42_1==WS))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch (alt42)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:182:29: WS
					{
					DebugLocation(182, 29);
					Match(input,WS,Follow._WS_in_resultTag1139); 

					}
					break;

				default:
					if (cnt42 >= 1)
						goto loop42;

					EarlyExitException eee42 = new EarlyExitException( 42, input );
					DebugRecognitionException(eee42);
					throw eee42;
				}
				cnt42++;
			}
			loop42:
				;

			} finally { DebugExitSubRule(42); }

			DebugLocation(182, 36);
			bar=(IToken)Match(input,GAME_RESULT,Follow._GAME_RESULT_in_resultTag1144); 
			DebugLocation(182, 49);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_resultTag1146); 
			DebugLocation(183, 1);

				Result = bar.Text.Trim(c_doubleQuote);


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("resultTag", 23);
			LeaveRule("resultTag", 23);
			LeaveRule_resultTag();
		}
		DebugLocation(185, 1);
		} finally { DebugExitRule(GrammarFileName, "resultTag"); }
		return;

	}
	// $ANTLR end "resultTag"

	partial void EnterRule_optionalTag();
	partial void LeaveRule_optionalTag();
	// $ANTLR start "optionalTag"
	// H:\\Work\\redchess\\PgnParser\\Pgn.g:187:1: optionalTag : LEFT_TAG (foo= TAG_NAME )+ ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("optionalTag")]
	private void optionalTag()
	{
		EnterRule_optionalTag();
		EnterRule("optionalTag", 24);
		TraceIn("optionalTag", 24);
		IToken foo = default(IToken);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "optionalTag");
		DebugLocation(187, 1);
		try
		{
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:187:13: ( LEFT_TAG (foo= TAG_NAME )+ ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:187:15: LEFT_TAG (foo= TAG_NAME )+ ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(187, 15);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_optionalTag1156); 
			DebugLocation(187, 27);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:187:27: (foo= TAG_NAME )+
			int cnt43=0;
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1==TAG_NAME))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:187:27: foo= TAG_NAME
					{
					DebugLocation(187, 27);
					foo=(IToken)Match(input,TAG_NAME,Follow._TAG_NAME_in_optionalTag1160); 

					}
					break;

				default:
					if (cnt43 >= 1)
						goto loop43;

					EarlyExitException eee43 = new EarlyExitException( 43, input );
					DebugRecognitionException(eee43);
					throw eee43;
				}
				cnt43++;
			}
			loop43:
				;

			} finally { DebugExitSubRule(43); }

			DebugLocation(187, 38);
			// H:\\Work\\redchess\\PgnParser\\Pgn.g:187:38: ( WS )+
			int cnt44=0;
			try { DebugEnterSubRule(44);
			while (true)
			{
				int alt44=2;
				try { DebugEnterDecision(44, false);
				int LA44_1 = input.LA(1);

				if ((LA44_1==WS))
				{
					alt44 = 1;
				}


				} finally { DebugExitDecision(44); }
				switch (alt44)
				{
				case 1:
					DebugEnterAlt(1);
					// H:\\Work\\redchess\\PgnParser\\Pgn.g:187:38: WS
					{
					DebugLocation(187, 38);
					Match(input,WS,Follow._WS_in_optionalTag1163); 

					}
					break;

				default:
					if (cnt44 >= 1)
						goto loop44;

					EarlyExitException eee44 = new EarlyExitException( 44, input );
					DebugRecognitionException(eee44);
					throw eee44;
				}
				cnt44++;
			}
			loop44:
				;

			} finally { DebugExitSubRule(44); }

			DebugLocation(187, 45);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_optionalTag1168); 
			DebugLocation(187, 60);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_optionalTag1170); 
			DebugLocation(188, 1);

				string trimmedText = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\"");
			    m_optionalTags.Add(foo.Text, trimmedText); 
				if(foo.Text == "FEN")
				{
				    // rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1
					m_processor.DoFen(trimmedText);
				}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("optionalTag", 24);
			LeaveRule("optionalTag", 24);
			LeaveRule_optionalTag();
		}
		DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "optionalTag"); }
		return;

	}
	// $ANTLR end "optionalTag"
	#endregion Rules


	#region DFA
	private DFA6 dfa6;
	private DFA14 dfa14;
	private DFA19 dfa19;
	private DFA21 dfa21;
	private DFA23 dfa23;
	private DFA32 dfa32;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa6 = new DFA6( this );
		dfa14 = new DFA14( this );
		dfa19 = new DFA19( this );
		dfa21 = new DFA21( this );
		dfa23 = new DFA23( this );
		dfa32 = new DFA32( this );
	}

	private class DFA6 : DFA
	{
		private const string DFA6_eotS =
			"\x26\xFFFF";
		private const string DFA6_eofS =
			"\x1\xFFFF\x1\x3\x2\xFFFF\x1\x3\x21\xFFFF";
		private const string DFA6_minS =
			"\x1\x12\x1\xE\x2\xFFFF\x1\xE\x1\x4\x7\x2D\x1\x27\x6\x1E\x1\xD\x1\x1E"+
			"\x8\x22\x8\xFFFF";
		private const string DFA6_maxS =
			"\x2\x2D\x2\xFFFF\x1\x2D\x1\x2C\x10\x2D\x8\x22\x8\xFFFF";
		private const string DFA6_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1A\xFFFF\x8\x1";
		private const string DFA6_specialS =
			"\x26\xFFFF}>";
		private static readonly string[] DFA6_transitionS =
			{
				"\x1\x2\x1A\xFFFF\x1\x1",
				"\x1\x3\x3\xFFFF\x1\x5\x3\xFFFF\x1\x3\x16\xFFFF\x1\x4",
				"",
				"",
				"\x1\x3\x3\xFFFF\x1\x5\x3\xFFFF\x1\x3\x16\xFFFF\x1\x4",
				"\x1\xA\x6\xFFFF\x1\x8\x1\x6\x12\xFFFF\x1\xC\x3\xFFFF\x1\x9\x1\xFFFF"+
				"\x1\x7\x1\xFFFF\x1\xD\x4\xFFFF\x1\xB",
				"\x1\xE",
				"\x1\xF",
				"\x1\x10",
				"\x1\x11",
				"\x1\x12",
				"\x1\x13",
				"\x1\x14",
				"\x1\xD\x5\xFFFF\x1\x15",
				"\x1\x16\xE\xFFFF\x1\xE",
				"\x1\x17\xE\xFFFF\x1\xF",
				"\x1\x18\xE\xFFFF\x1\x10",
				"\x1\x19\xE\xFFFF\x1\x11",
				"\x1\x1A\xE\xFFFF\x1\x12",
				"\x1\x1B\xE\xFFFF\x1\x13",
				"\x1\x1C\x1F\xFFFF\x1\x14",
				"\x1\x1D\xE\xFFFF\x1\x15",
				"\x1\x1E",
				"\x1\x1F",
				"\x1\x20",
				"\x1\x21",
				"\x1\x22",
				"\x1\x23",
				"\x1\x24",
				"\x1\x25",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA6_eot = DFA.UnpackEncodedString(DFA6_eotS);
		private static readonly short[] DFA6_eof = DFA.UnpackEncodedString(DFA6_eofS);
		private static readonly char[] DFA6_min = DFA.UnpackEncodedStringToUnsignedChars(DFA6_minS);
		private static readonly char[] DFA6_max = DFA.UnpackEncodedStringToUnsignedChars(DFA6_maxS);
		private static readonly short[] DFA6_accept = DFA.UnpackEncodedString(DFA6_acceptS);
		private static readonly short[] DFA6_special = DFA.UnpackEncodedString(DFA6_specialS);
		private static readonly short[][] DFA6_transition;

		static DFA6()
		{
			int numStates = DFA6_transitionS.Length;
			DFA6_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA6_transition[i] = DFA.UnpackEncodedString(DFA6_transitionS[i]);
			}
		}

		public DFA6( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 6;
			this.eot = DFA6_eot;
			this.eof = DFA6_eof;
			this.min = DFA6_min;
			this.max = DFA6_max;
			this.accept = DFA6_accept;
			this.special = DFA6_special;
			this.transition = DFA6_transition;
		}

		public override string Description { get { return "()* loopback of 107:46: ( ( WS )* ( optionalTag | compulsoryTag ) )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA14 : DFA
	{
		private const string DFA14_eotS =
			"\x5\xFFFF";
		private const string DFA14_eofS =
			"\x2\x2\x1\xFFFF\x1\x2\x1\xFFFF";
		private const string DFA14_minS =
			"\x1\xE\x1\x5\x1\xFFFF\x1\x5\x1\xFFFF";
		private const string DFA14_maxS =
			"\x2\x2D\x1\xFFFF\x1\x2D\x1\xFFFF";
		private const string DFA14_acceptS =
			"\x2\xFFFF\x1\x2\x1\xFFFF\x1\x1";
		private const string DFA14_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA14_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x1\x4\x3\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x4\x1\xFFFF\x1\x2\x3\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x3",
				"",
				"\x1\x4\x3\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x4\x1\xFFFF\x1\x2\x3\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x3",
				""
			};

		private static readonly short[] DFA14_eot = DFA.UnpackEncodedString(DFA14_eotS);
		private static readonly short[] DFA14_eof = DFA.UnpackEncodedString(DFA14_eofS);
		private static readonly char[] DFA14_min = DFA.UnpackEncodedStringToUnsignedChars(DFA14_minS);
		private static readonly char[] DFA14_max = DFA.UnpackEncodedStringToUnsignedChars(DFA14_maxS);
		private static readonly short[] DFA14_accept = DFA.UnpackEncodedString(DFA14_acceptS);
		private static readonly short[] DFA14_special = DFA.UnpackEncodedString(DFA14_specialS);
		private static readonly short[][] DFA14_transition;

		static DFA14()
		{
			int numStates = DFA14_transitionS.Length;
			DFA14_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA14_transition[i] = DFA.UnpackEncodedString(DFA14_transitionS[i]);
			}
		}

		public DFA14( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 14;
			this.eot = DFA14_eot;
			this.eof = DFA14_eof;
			this.min = DFA14_min;
			this.max = DFA14_max;
			this.accept = DFA14_accept;
			this.special = DFA14_special;
			this.transition = DFA14_transition;
		}

		public override string Description { get { return "()* loopback of 119:29: ( ( WS )+ annotation )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA19 : DFA
	{
		private const string DFA19_eotS =
			"\x5\xFFFF";
		private const string DFA19_eofS =
			"\x2\x2\x2\xFFFF\x1\x2";
		private const string DFA19_minS =
			"\x1\xE\x1\x5\x2\xFFFF\x1\x5";
		private const string DFA19_maxS =
			"\x2\x2D\x2\xFFFF\x1\x2D";
		private const string DFA19_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA19_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA19_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x4\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x2\x2"+
				"\x1\x3\x1\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4",
				"",
				"",
				"\x4\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x2\x2"+
				"\x1\x3\x1\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4"
			};

		private static readonly short[] DFA19_eot = DFA.UnpackEncodedString(DFA19_eotS);
		private static readonly short[] DFA19_eof = DFA.UnpackEncodedString(DFA19_eofS);
		private static readonly char[] DFA19_min = DFA.UnpackEncodedStringToUnsignedChars(DFA19_minS);
		private static readonly char[] DFA19_max = DFA.UnpackEncodedStringToUnsignedChars(DFA19_maxS);
		private static readonly short[] DFA19_accept = DFA.UnpackEncodedString(DFA19_acceptS);
		private static readonly short[] DFA19_special = DFA.UnpackEncodedString(DFA19_specialS);
		private static readonly short[][] DFA19_transition;

		static DFA19()
		{
			int numStates = DFA19_transitionS.Length;
			DFA19_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA19_transition[i] = DFA.UnpackEncodedString(DFA19_transitionS[i]);
			}
		}

		public DFA19( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 19;
			this.eot = DFA19_eot;
			this.eof = DFA19_eof;
			this.min = DFA19_min;
			this.max = DFA19_max;
			this.accept = DFA19_accept;
			this.special = DFA19_special;
			this.transition = DFA19_transition;
		}

		public override string Description { get { return "120:166: ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA21 : DFA
	{
		private const string DFA21_eotS =
			"\x5\xFFFF";
		private const string DFA21_eofS =
			"\x2\x2\x2\xFFFF\x1\x2";
		private const string DFA21_minS =
			"\x1\xE\x1\x5\x2\xFFFF\x1\x5";
		private const string DFA21_maxS =
			"\x2\x2D\x2\xFFFF\x1\x2D";
		private const string DFA21_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA21_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA21_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x1\x3\x3\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x1\x2\x3\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4",
				"",
				"",
				"\x1\x3\x3\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x1\x2\x3\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4"
			};

		private static readonly short[] DFA21_eot = DFA.UnpackEncodedString(DFA21_eotS);
		private static readonly short[] DFA21_eof = DFA.UnpackEncodedString(DFA21_eofS);
		private static readonly char[] DFA21_min = DFA.UnpackEncodedStringToUnsignedChars(DFA21_minS);
		private static readonly char[] DFA21_max = DFA.UnpackEncodedStringToUnsignedChars(DFA21_maxS);
		private static readonly short[] DFA21_accept = DFA.UnpackEncodedString(DFA21_acceptS);
		private static readonly short[] DFA21_special = DFA.UnpackEncodedString(DFA21_specialS);
		private static readonly short[][] DFA21_transition;

		static DFA21()
		{
			int numStates = DFA21_transitionS.Length;
			DFA21_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA21_transition[i] = DFA.UnpackEncodedString(DFA21_transitionS[i]);
			}
		}

		public DFA21( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 21;
			this.eot = DFA21_eot;
			this.eof = DFA21_eof;
			this.min = DFA21_min;
			this.max = DFA21_max;
			this.accept = DFA21_accept;
			this.special = DFA21_special;
			this.transition = DFA21_transition;
		}

		public override string Description { get { return "120:215: ( ( WS )+ annotationList )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA23 : DFA
	{
		private const string DFA23_eotS =
			"\x4\xFFFF";
		private const string DFA23_eofS =
			"\x2\x2\x2\xFFFF";
		private const string DFA23_minS =
			"\x2\xE\x2\xFFFF";
		private const string DFA23_maxS =
			"\x2\x2D\x2\xFFFF";
		private const string DFA23_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA23_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA23_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x1\x2\x3\xFFFF\x1\x2\x3\xFFFF\x1\x3\x9\xFFFF\x1\x2\xC\xFFFF\x1\x1",
				"",
				""
			};

		private static readonly short[] DFA23_eot = DFA.UnpackEncodedString(DFA23_eotS);
		private static readonly short[] DFA23_eof = DFA.UnpackEncodedString(DFA23_eofS);
		private static readonly char[] DFA23_min = DFA.UnpackEncodedStringToUnsignedChars(DFA23_minS);
		private static readonly char[] DFA23_max = DFA.UnpackEncodedStringToUnsignedChars(DFA23_maxS);
		private static readonly short[] DFA23_accept = DFA.UnpackEncodedString(DFA23_acceptS);
		private static readonly short[] DFA23_special = DFA.UnpackEncodedString(DFA23_specialS);
		private static readonly short[][] DFA23_transition;

		static DFA23()
		{
			int numStates = DFA23_transitionS.Length;
			DFA23_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA23_transition[i] = DFA.UnpackEncodedString(DFA23_transitionS[i]);
			}
		}

		public DFA23( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 23;
			this.eot = DFA23_eot;
			this.eof = DFA23_eof;
			this.min = DFA23_min;
			this.max = DFA23_max;
			this.accept = DFA23_accept;
			this.special = DFA23_special;
			this.transition = DFA23_transition;
		}

		public override string Description { get { return "()* loopback of 127:17: ( ( WS )+ move )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA32 : DFA
	{
		private const string DFA32_eotS =
			"\xA\xFFFF";
		private const string DFA32_eofS =
			"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF";
		private const string DFA32_minS =
			"\x1\xE\x1\x6\x1\xFFFF\x2\x6\x1\xFFFF\x3\x6\x1\xFFFF";
		private const string DFA32_maxS =
			"\x2\x2D\x1\xFFFF\x2\x2D\x1\xFFFF\x3\x2D\x1\xFFFF";
		private const string DFA32_acceptS =
			"\x2\xFFFF\x1\x2\x2\xFFFF\x1\x1\x3\xFFFF\x1\x1";
		private const string DFA32_specialS =
			"\xA\xFFFF}>";
		private static readonly string[] DFA32_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x3\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x3\x5\x5\xFFFF\x1\x2\x3\xFFFF\x1\x2\x3\xFFFF\x1\x3\x1\x5\x2\xFFFF"+
				"\x1\x5\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4",
				"",
				"\x3\x2\xE\xFFFF\x1\x7\x2\xFFFF\x1\x2\x12\xFFFF\x1\x6",
				"\x3\x5\x5\xFFFF\x1\x2\x3\xFFFF\x1\x2\x3\xFFFF\x1\x3\x1\x5\x2\xFFFF"+
				"\x1\x5\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4",
				"",
				"\x3\x2\xE\xFFFF\x1\x7\x2\xFFFF\x1\x2\x12\xFFFF\x1\x6",
				"\x3\x9\x11\xFFFF\x1\x9\x12\xFFFF\x1\x8",
				"\x3\x9\x11\xFFFF\x1\x9\x12\xFFFF\x1\x8",
				""
			};

		private static readonly short[] DFA32_eot = DFA.UnpackEncodedString(DFA32_eotS);
		private static readonly short[] DFA32_eof = DFA.UnpackEncodedString(DFA32_eofS);
		private static readonly char[] DFA32_min = DFA.UnpackEncodedStringToUnsignedChars(DFA32_minS);
		private static readonly char[] DFA32_max = DFA.UnpackEncodedStringToUnsignedChars(DFA32_maxS);
		private static readonly short[] DFA32_accept = DFA.UnpackEncodedString(DFA32_acceptS);
		private static readonly short[] DFA32_special = DFA.UnpackEncodedString(DFA32_specialS);
		private static readonly short[][] DFA32_transition;

		static DFA32()
		{
			int numStates = DFA32_transitionS.Length;
			DFA32_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA32_transition[i] = DFA.UnpackEncodedString(DFA32_transitionS[i]);
			}
		}

		public DFA32( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 32;
			this.eot = DFA32_eot;
			this.eof = DFA32_eof;
			this.min = DFA32_min;
			this.max = DFA32_max;
			this.accept = DFA32_accept;
			this.special = DFA32_special;
			this.transition = DFA32_transition;
		}

		public override string Description { get { return "129:53: ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _document_in_parse660 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compulsoryTag_in_parseTag670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _optionalTag_in_parseTag674 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _gameList_in_document683 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_document685 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _game_in_gameList694 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _optionalTag_in_generalTagList706 = new BitSet(new ulong[]{0x200000040002UL});
		public static readonly BitSet _compulsoryTag_in_generalTagList708 = new BitSet(new ulong[]{0x200000040002UL});
		public static readonly BitSet _WS_in_generalTagList712 = new BitSet(new ulong[]{0x200000040000UL});
		public static readonly BitSet _optionalTag_in_generalTagList716 = new BitSet(new ulong[]{0x200000040002UL});
		public static readonly BitSet _compulsoryTag_in_generalTagList718 = new BitSet(new ulong[]{0x200000040002UL});
		public static readonly BitSet _generalTagList_in_game730 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _WS_in_game732 = new BitSet(new ulong[]{0x200000404002UL});
		public static readonly BitSet _moveList_in_game736 = new BitSet(new ulong[]{0x200000004002UL});
		public static readonly BitSet _WS_in_game740 = new BitSet(new ulong[]{0x200000004002UL});
		public static readonly BitSet _GAME_RESULT_END_OF_MOVETEXT_in_game743 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _WS_in_game746 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _blockComment_in_annotation758 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variantLine_in_annotation762 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _annotation_in_annotationList771 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _WS_in_annotationList774 = new BitSet(new ulong[]{0x200000010020UL});
		public static readonly BitSet _annotation_in_annotationList777 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _set_in_individualMove789 = new BitSet(new ulong[]{0x200010300202UL});
		public static readonly BitSet _PROMOTES_TO_PIECE_in_individualMove805 = new BitSet(new ulong[]{0x200000300202UL});
		public static readonly BitSet _CHECK_in_individualMove812 = new BitSet(new ulong[]{0x200000200002UL});
		public static readonly BitSet _MATE_in_individualMove816 = new BitSet(new ulong[]{0x200000200002UL});
		public static readonly BitSet _MOVE_ANALYSIS_in_individualMove820 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _WS_in_individualMove824 = new BitSet(new ulong[]{0x200001000000UL});
		public static readonly BitSet _NUMERIC_ANNOTATION_GLYPH_in_individualMove829 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _WS_in_individualMove834 = new BitSet(new ulong[]{0x200000010020UL});
		public static readonly BitSet _annotationList_in_individualMove837 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _move_in_moveList851 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _WS_in_moveList854 = new BitSet(new ulong[]{0x200000400000UL});
		public static readonly BitSet _move_in_moveList857 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _MOVE_LABEL_in_move868 = new BitSet(new ulong[]{0x2000048001C0UL});
		public static readonly BitSet _WS_in_move870 = new BitSet(new ulong[]{0x2000048001C0UL});
		public static readonly BitSet _NO_MOVE_in_move874 = new BitSet(new ulong[]{0x2000040001C0UL});
		public static readonly BitSet _WS_in_move876 = new BitSet(new ulong[]{0x2000040001C0UL});
		public static readonly BitSet _individualMove_in_move881 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _WS_in_move884 = new BitSet(new ulong[]{0x200004C001C0UL});
		public static readonly BitSet _MOVE_LABEL_in_move888 = new BitSet(new ulong[]{0x200000800000UL});
		public static readonly BitSet _WS_in_move891 = new BitSet(new ulong[]{0x200000800000UL});
		public static readonly BitSet _NO_MOVE_in_move894 = new BitSet(new ulong[]{0x2000040001C0UL});
		public static readonly BitSet _WS_in_move896 = new BitSet(new ulong[]{0x2000040001C0UL});
		public static readonly BitSet _individualMove_in_move901 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _eventTag_in_compulsoryTag912 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _siteTag_in_compulsoryTag916 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dateTag_in_compulsoryTag920 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _roundTag_in_compulsoryTag924 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blackTag_in_compulsoryTag928 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whiteTag_in_compulsoryTag932 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _resultTag_in_compulsoryTag936 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCK_COMMENT_in_blockComment948 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_BRACKET_in_enterVariant958 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RIGHT_BRACKET_in_leaveVariant968 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enterVariant_in_variantLine978 = new BitSet(new ulong[]{0x200100410000UL});
		public static readonly BitSet _moveList_in_variantLine981 = new BitSet(new ulong[]{0x200100410000UL});
		public static readonly BitSet _variantLine_in_variantLine985 = new BitSet(new ulong[]{0x200100410000UL});
		public static readonly BitSet _WS_in_variantLine989 = new BitSet(new ulong[]{0x200100000000UL});
		public static readonly BitSet _leaveVariant_in_variantLine992 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_eventTag1002 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _EVENT_in_eventTag1004 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _WS_in_eventTag1006 = new BitSet(new ulong[]{0x200040000000UL});
		public static readonly BitSet _QUOTED_STRING_in_eventTag1011 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _RIGHT_TAG_in_eventTag1013 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_siteTag1024 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _SITE_in_siteTag1026 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _WS_in_siteTag1028 = new BitSet(new ulong[]{0x200040000000UL});
		public static readonly BitSet _QUOTED_STRING_in_siteTag1033 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _RIGHT_TAG_in_siteTag1035 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_dateTag1046 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _DATE_in_dateTag1048 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _WS_in_dateTag1050 = new BitSet(new ulong[]{0x200040000000UL});
		public static readonly BitSet _QUOTED_STRING_in_dateTag1055 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _RIGHT_TAG_in_dateTag1057 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_roundTag1068 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _ROUND_in_roundTag1070 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _WS_in_roundTag1072 = new BitSet(new ulong[]{0x200040000000UL});
		public static readonly BitSet _QUOTED_STRING_in_roundTag1077 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _RIGHT_TAG_in_roundTag1079 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_blackTag1090 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _BLACK_in_blackTag1093 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _WS_in_blackTag1095 = new BitSet(new ulong[]{0x200040000000UL});
		public static readonly BitSet _QUOTED_STRING_in_blackTag1100 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _RIGHT_TAG_in_blackTag1102 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_whiteTag1113 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _WHITE_in_whiteTag1115 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _WS_in_whiteTag1117 = new BitSet(new ulong[]{0x200040000000UL});
		public static readonly BitSet _QUOTED_STRING_in_whiteTag1122 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _RIGHT_TAG_in_whiteTag1124 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_resultTag1135 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _RESULT_in_resultTag1137 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _WS_in_resultTag1139 = new BitSet(new ulong[]{0x200000002000UL});
		public static readonly BitSet _GAME_RESULT_in_resultTag1144 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _RIGHT_TAG_in_resultTag1146 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_optionalTag1156 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _TAG_NAME_in_optionalTag1160 = new BitSet(new ulong[]{0x208000000000UL});
		public static readonly BitSet _WS_in_optionalTag1163 = new BitSet(new ulong[]{0x200040000000UL});
		public static readonly BitSet _QUOTED_STRING_in_optionalTag1168 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _RIGHT_TAG_in_optionalTag1170 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Redchess.Pgn 
