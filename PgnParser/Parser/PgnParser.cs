//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.1 C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g 2014-06-27 20:43:14

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  Redchess.Pgn 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.1")]
[System.CLSCompliant(false)]
public partial class PgnParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BLACK", "BLOCK_COMMENT", "CAPTURE", "CASTLE_KINGSIDE", "CASTLE_QUEENSIDE", "CHECK", "COLUMN", "DATE", "EVENT", "GAME_RESULT", "GAME_RESULT_END_OF_MOVETEXT", "INTEGER", "LEFT_BRACKET", "LEFT_CURLY_BRACKET", "LEFT_TAG", "LINE_COMMENT", "MATE", "MOVE_LABEL", "NO_MOVE", "NUMERIC_ANNOTATION_GLYPH", "PIECE_SYMBOL", "PIECE_TO_SQUARE", "PROMOTES_TO", "PROMOTES_TO_PIECE", "QUOTE", "QUOTED_STRING", "RESULT", "RIGHT_BRACKET", "RIGHT_CURLY_BRACKET", "RIGHT_TAG", "ROUND", "ROW", "SITE", "SQUARE", "TAG_NAME", "TAKES", "UNAMBIGUOUS_PIECE_WITH_COLUMN", "UNAMBIGUOUS_PIECE_WITH_ROW", "UNAMBIGUOUS_PIECE_WITH_ROW_AND_COLUMN", "WHITE", "WS"
	};
	public const int EOF=-1;
	public const int BLACK=4;
	public const int BLOCK_COMMENT=5;
	public const int CAPTURE=6;
	public const int CASTLE_KINGSIDE=7;
	public const int CASTLE_QUEENSIDE=8;
	public const int CHECK=9;
	public const int COLUMN=10;
	public const int DATE=11;
	public const int EVENT=12;
	public const int GAME_RESULT=13;
	public const int GAME_RESULT_END_OF_MOVETEXT=14;
	public const int INTEGER=15;
	public const int LEFT_BRACKET=16;
	public const int LEFT_CURLY_BRACKET=17;
	public const int LEFT_TAG=18;
	public const int LINE_COMMENT=19;
	public const int MATE=20;
	public const int MOVE_LABEL=21;
	public const int NO_MOVE=22;
	public const int NUMERIC_ANNOTATION_GLYPH=23;
	public const int PIECE_SYMBOL=24;
	public const int PIECE_TO_SQUARE=25;
	public const int PROMOTES_TO=26;
	public const int PROMOTES_TO_PIECE=27;
	public const int QUOTE=28;
	public const int QUOTED_STRING=29;
	public const int RESULT=30;
	public const int RIGHT_BRACKET=31;
	public const int RIGHT_CURLY_BRACKET=32;
	public const int RIGHT_TAG=33;
	public const int ROUND=34;
	public const int ROW=35;
	public const int SITE=36;
	public const int SQUARE=37;
	public const int TAG_NAME=38;
	public const int TAKES=39;
	public const int UNAMBIGUOUS_PIECE_WITH_COLUMN=40;
	public const int UNAMBIGUOUS_PIECE_WITH_ROW=41;
	public const int UNAMBIGUOUS_PIECE_WITH_ROW_AND_COLUMN=42;
	public const int WHITE=43;
	public const int WS=44;

	public PgnParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public PgnParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return PgnParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g"; } }


		private int m_variantDepth = 0;
		public bool PlayGame;
	    private static char[] c_doubleQuote = new [] { '"' }; 

		private Dictionary<string,string> m_optionalTags = new Dictionary<string,string>();
		public IDictionary<string,string> OptionalTags { get { return m_optionalTags; } }

		public string Event { get; private set; }
		public string Site { get; private set; }
		public string Date { get; private set; }
		public string Round { get; private set; }
		public string Black { get; private set; }
		public string White { get; private set; }
		public string Result { get; private set; }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_parse();
	partial void LeaveRule_parse();
	// $ANTLR start "parse"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:97:8: public parse : document ;
	[GrammarRule("parse")]
	public void parse()
	{
		EnterRule_parse();
		EnterRule("parse", 1);
		TraceIn("parse", 1);
		try { DebugEnterRule(GrammarFileName, "parse");
		DebugLocation(97, 24);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:97:14: ( document )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:97:16: document
			{
			DebugLocation(97, 16);
			PushFollow(Follow._document_in_parse628);
			document();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parse", 1);
			LeaveRule("parse", 1);
			LeaveRule_parse();
		}
		DebugLocation(97, 24);
		} finally { DebugExitRule(GrammarFileName, "parse"); }
		return;

	}
	// $ANTLR end "parse"

	partial void EnterRule_parseTag();
	partial void LeaveRule_parseTag();
	// $ANTLR start "parseTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:98:8: public parseTag : ( compulsoryTag | optionalTag );
	[GrammarRule("parseTag")]
	public void parseTag()
	{
		EnterRule_parseTag();
		EnterRule("parseTag", 2);
		TraceIn("parseTag", 2);
		try { DebugEnterRule(GrammarFileName, "parseTag");
		DebugLocation(98, 46);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:98:17: ( compulsoryTag | optionalTag )
			int alt1=2;
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1==LEFT_TAG))
			{
				int LA1_2 = input.LA(2);

				if ((LA1_2==BLACK||(LA1_2>=DATE && LA1_2<=EVENT)||LA1_2==RESULT||LA1_2==ROUND||LA1_2==SITE||LA1_2==WHITE))
				{
					alt1 = 1;
				}
				else if ((LA1_2==TAG_NAME))
				{
					alt1 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:98:19: compulsoryTag
				{
				DebugLocation(98, 19);
				PushFollow(Follow._compulsoryTag_in_parseTag638);
				compulsoryTag();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:98:35: optionalTag
				{
				DebugLocation(98, 35);
				PushFollow(Follow._optionalTag_in_parseTag642);
				optionalTag();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parseTag", 2);
			LeaveRule("parseTag", 2);
			LeaveRule_parseTag();
		}
		DebugLocation(98, 46);
		} finally { DebugExitRule(GrammarFileName, "parseTag"); }
		return;

	}
	// $ANTLR end "parseTag"

	partial void EnterRule_document();
	partial void LeaveRule_document();
	// $ANTLR start "document"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:100:1: document : gameList EOF ;
	[GrammarRule("document")]
	private void document()
	{
		EnterRule_document();
		EnterRule("document", 3);
		TraceIn("document", 3);
		try { DebugEnterRule(GrammarFileName, "document");
		DebugLocation(100, 24);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:100:10: ( gameList EOF )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:100:12: gameList EOF
			{
			DebugLocation(100, 12);
			PushFollow(Follow._gameList_in_document651);
			gameList();
			PopFollow();

			DebugLocation(100, 21);
			Match(input,EOF,Follow._EOF_in_document653); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("document", 3);
			LeaveRule("document", 3);
			LeaveRule_document();
		}
		DebugLocation(100, 24);
		} finally { DebugExitRule(GrammarFileName, "document"); }
		return;

	}
	// $ANTLR end "document"

	partial void EnterRule_gameList();
	partial void LeaveRule_gameList();
	// $ANTLR start "gameList"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:102:1: gameList : ( game )+ ;
	[GrammarRule("gameList")]
	private void gameList()
	{
		EnterRule_gameList();
		EnterRule("gameList", 4);
		TraceIn("gameList", 4);
		try { DebugEnterRule(GrammarFileName, "gameList");
		DebugLocation(102, 17);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:102:10: ( ( game )+ )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:102:12: ( game )+
			{
			DebugLocation(102, 12);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:102:12: ( game )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==LEFT_TAG))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:102:12: game
					{
					DebugLocation(102, 12);
					PushFollow(Follow._game_in_gameList662);
					game();
					PopFollow();


					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("gameList", 4);
			LeaveRule("gameList", 4);
			LeaveRule_gameList();
		}
		DebugLocation(102, 17);
		} finally { DebugExitRule(GrammarFileName, "gameList"); }
		return;

	}
	// $ANTLR end "gameList"

	partial void EnterRule_generalTagList();
	partial void LeaveRule_generalTagList();
	// $ANTLR start "generalTagList"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:1: generalTagList : ( optionalTag | compulsoryTag ) ( ( WS )* ( optionalTag | compulsoryTag ) )* ;
	[GrammarRule("generalTagList")]
	private void generalTagList()
	{
		EnterRule_generalTagList();
		EnterRule("generalTagList", 5);
		TraceIn("generalTagList", 5);
		try { DebugEnterRule(GrammarFileName, "generalTagList");
		DebugLocation(105, 80);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:16: ( ( optionalTag | compulsoryTag ) ( ( WS )* ( optionalTag | compulsoryTag ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:18: ( optionalTag | compulsoryTag ) ( ( WS )* ( optionalTag | compulsoryTag ) )*
			{
			DebugLocation(105, 18);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:18: ( optionalTag | compulsoryTag )
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==LEFT_TAG))
			{
				int LA3_2 = input.LA(2);

				if ((LA3_2==BLACK||(LA3_2>=DATE && LA3_2<=EVENT)||LA3_2==RESULT||LA3_2==ROUND||LA3_2==SITE||LA3_2==WHITE))
				{
					alt3 = 2;
				}
				else if ((LA3_2==TAG_NAME))
				{
					alt3 = 1;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:19: optionalTag
				{
				DebugLocation(105, 19);
				PushFollow(Follow._optionalTag_in_generalTagList674);
				optionalTag();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:31: compulsoryTag
				{
				DebugLocation(105, 31);
				PushFollow(Follow._compulsoryTag_in_generalTagList676);
				compulsoryTag();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(105, 46);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:46: ( ( WS )* ( optionalTag | compulsoryTag ) )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				try
				{
					alt6 = dfa6.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:47: ( WS )* ( optionalTag | compulsoryTag )
					{
					DebugLocation(105, 47);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:47: ( WS )*
					try { DebugEnterSubRule(4);
					while (true)
					{
						int alt4=2;
						try { DebugEnterDecision(4, false);
						int LA4_1 = input.LA(1);

						if ((LA4_1==WS))
						{
							alt4 = 1;
						}


						} finally { DebugExitDecision(4); }
						switch ( alt4 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:47: WS
							{
							DebugLocation(105, 47);
							Match(input,WS,Follow._WS_in_generalTagList680); 

							}
							break;

						default:
							goto loop4;
						}
					}

					loop4:
						;

					} finally { DebugExitSubRule(4); }

					DebugLocation(105, 51);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:51: ( optionalTag | compulsoryTag )
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1==LEFT_TAG))
					{
						int LA5_2 = input.LA(2);

						if ((LA5_2==BLACK||(LA5_2>=DATE && LA5_2<=EVENT)||LA5_2==RESULT||LA5_2==ROUND||LA5_2==SITE||LA5_2==WHITE))
						{
							alt5 = 2;
						}
						else if ((LA5_2==TAG_NAME))
						{
							alt5 = 1;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 5, 1, input, 2);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:52: optionalTag
						{
						DebugLocation(105, 52);
						PushFollow(Follow._optionalTag_in_generalTagList684);
						optionalTag();
						PopFollow();


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:105:64: compulsoryTag
						{
						DebugLocation(105, 64);
						PushFollow(Follow._compulsoryTag_in_generalTagList686);
						compulsoryTag();
						PopFollow();


						}
						break;

					}
					} finally { DebugExitSubRule(5); }


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("generalTagList", 5);
			LeaveRule("generalTagList", 5);
			LeaveRule_generalTagList();
		}
		DebugLocation(105, 80);
		} finally { DebugExitRule(GrammarFileName, "generalTagList"); }
		return;

	}
	// $ANTLR end "generalTagList"

	partial void EnterRule_game();
	partial void LeaveRule_game();
	// $ANTLR start "game"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:1: game : generalTagList ( WS )+ ( moveList )? ( WS )* ( GAME_RESULT_END_OF_MOVETEXT )? ( WS )* ;
	[GrammarRule("game")]
	private void game()
	{
		EnterRule_game();
		EnterRule("game", 6);
		TraceIn("game", 6);
		try { DebugEnterRule(GrammarFileName, "game");
		DebugLocation(107, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:6: ( generalTagList ( WS )+ ( moveList )? ( WS )* ( GAME_RESULT_END_OF_MOVETEXT )? ( WS )* )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:8: generalTagList ( WS )+ ( moveList )? ( WS )* ( GAME_RESULT_END_OF_MOVETEXT )? ( WS )*
			{
			DebugLocation(107, 8);
			PushFollow(Follow._generalTagList_in_game698);
			generalTagList();
			PopFollow();

			DebugLocation(107, 23);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:23: ( WS )+
			int cnt7=0;
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==WS))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:23: WS
					{
					DebugLocation(107, 23);
					Match(input,WS,Follow._WS_in_game700); 

					}
					break;

				default:
					if (cnt7 >= 1)
						goto loop7;

					EarlyExitException eee7 = new EarlyExitException( 7, input );
					DebugRecognitionException(eee7);
					throw eee7;
				}
				cnt7++;
			}
			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(107, 27);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:27: ( moveList )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==MOVE_LABEL))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:28: moveList
				{
				DebugLocation(107, 28);
				PushFollow(Follow._moveList_in_game704);
				moveList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(107, 39);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:39: ( WS )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==WS))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:39: WS
					{
					DebugLocation(107, 39);
					Match(input,WS,Follow._WS_in_game708); 

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(107, 43);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:43: ( GAME_RESULT_END_OF_MOVETEXT )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==GAME_RESULT_END_OF_MOVETEXT))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:43: GAME_RESULT_END_OF_MOVETEXT
				{
				DebugLocation(107, 43);
				Match(input,GAME_RESULT_END_OF_MOVETEXT,Follow._GAME_RESULT_END_OF_MOVETEXT_in_game711); 

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(107, 72);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:72: ( WS )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==WS))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:107:72: WS
					{
					DebugLocation(107, 72);
					Match(input,WS,Follow._WS_in_game714); 

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(108, 1);

				if(PlayGame)
				{
					m_processor.ResetGame();
					m_optionalTags.Clear();
				}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("game", 6);
			LeaveRule("game", 6);
			LeaveRule_game();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "game"); }
		return;

	}
	// $ANTLR end "game"

	partial void EnterRule_annotation();
	partial void LeaveRule_annotation();
	// $ANTLR start "annotation"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:116:1: annotation : ( blockComment | variantLine ) ;
	[GrammarRule("annotation")]
	private void annotation()
	{
		EnterRule_annotation();
		EnterRule("annotation", 7);
		TraceIn("annotation", 7);
		try { DebugEnterRule(GrammarFileName, "annotation");
		DebugLocation(116, 42);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:116:12: ( ( blockComment | variantLine ) )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:116:14: ( blockComment | variantLine )
			{
			DebugLocation(116, 14);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:116:14: ( blockComment | variantLine )
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==BLOCK_COMMENT))
			{
				alt12 = 1;
			}
			else if ((LA12_1==LEFT_BRACKET))
			{
				alt12 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:116:15: blockComment
				{
				DebugLocation(116, 15);
				PushFollow(Follow._blockComment_in_annotation726);
				blockComment();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:116:30: variantLine
				{
				DebugLocation(116, 30);
				PushFollow(Follow._variantLine_in_annotation730);
				variantLine();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(12); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("annotation", 7);
			LeaveRule("annotation", 7);
			LeaveRule_annotation();
		}
		DebugLocation(116, 42);
		} finally { DebugExitRule(GrammarFileName, "annotation"); }
		return;

	}
	// $ANTLR end "annotation"

	partial void EnterRule_annotationList();
	partial void LeaveRule_annotationList();
	// $ANTLR start "annotationList"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:117:1: annotationList : annotation ( ( WS )+ annotation )* ;
	[GrammarRule("annotationList")]
	private void annotationList()
	{
		EnterRule_annotationList();
		EnterRule("annotationList", 8);
		TraceIn("annotationList", 8);
		try { DebugEnterRule(GrammarFileName, "annotationList");
		DebugLocation(117, 46);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:117:16: ( annotation ( ( WS )+ annotation )* )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:117:18: annotation ( ( WS )+ annotation )*
			{
			DebugLocation(117, 18);
			PushFollow(Follow._annotation_in_annotationList739);
			annotation();
			PopFollow();

			DebugLocation(117, 29);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:117:29: ( ( WS )+ annotation )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				try
				{
					alt14 = dfa14.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:117:30: ( WS )+ annotation
					{
					DebugLocation(117, 30);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:117:30: ( WS )+
					int cnt13=0;
					try { DebugEnterSubRule(13);
					while (true)
					{
						int alt13=2;
						try { DebugEnterDecision(13, false);
						int LA13_1 = input.LA(1);

						if ((LA13_1==WS))
						{
							alt13 = 1;
						}


						} finally { DebugExitDecision(13); }
						switch (alt13)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:117:30: WS
							{
							DebugLocation(117, 30);
							Match(input,WS,Follow._WS_in_annotationList742); 

							}
							break;

						default:
							if (cnt13 >= 1)
								goto loop13;

							EarlyExitException eee13 = new EarlyExitException( 13, input );
							DebugRecognitionException(eee13);
							throw eee13;
						}
						cnt13++;
					}
					loop13:
						;

					} finally { DebugExitSubRule(13); }

					DebugLocation(117, 34);
					PushFollow(Follow._annotation_in_annotationList745);
					annotation();
					PopFollow();


					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("annotationList", 8);
			LeaveRule("annotationList", 8);
			LeaveRule_annotationList();
		}
		DebugLocation(117, 46);
		} finally { DebugExitRule(GrammarFileName, "annotationList"); }
		return;

	}
	// $ANTLR end "annotationList"

	partial void EnterRule_individualMove();
	partial void LeaveRule_individualMove();
	// $ANTLR start "individualMove"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:1: individualMove : foo= ( PIECE_TO_SQUARE | CAPTURE | CASTLE_KINGSIDE | CASTLE_QUEENSIDE ) (promote= PROMOTES_TO_PIECE )? (checkormate= CHECK |checkormate= MATE )? ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )? ( ( WS )+ annotationList )? ;
	[GrammarRule("individualMove")]
	private void individualMove()
	{
		EnterRule_individualMove();
		EnterRule("individualMove", 9);
		TraceIn("individualMove", 9);
		IToken foo = default(IToken);
		IToken promote = default(IToken);
		IToken checkormate = default(IToken);
		IToken annotation_glyph = default(IToken);

		try { DebugEnterRule(GrammarFileName, "individualMove");
		DebugLocation(118, 2);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:16: (foo= ( PIECE_TO_SQUARE | CAPTURE | CASTLE_KINGSIDE | CASTLE_QUEENSIDE ) (promote= PROMOTES_TO_PIECE )? (checkormate= CHECK |checkormate= MATE )? ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )? ( ( WS )+ annotationList )? )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:18: foo= ( PIECE_TO_SQUARE | CAPTURE | CASTLE_KINGSIDE | CASTLE_QUEENSIDE ) (promote= PROMOTES_TO_PIECE )? (checkormate= CHECK |checkormate= MATE )? ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )? ( ( WS )+ annotationList )?
			{
			DebugLocation(118, 21);

			foo=(IToken)input.LT(1);
			if ((input.LA(1)>=CAPTURE && input.LA(1)<=CASTLE_QUEENSIDE)||input.LA(1)==PIECE_TO_SQUARE)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(118, 84);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:84: (promote= PROMOTES_TO_PIECE )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==PROMOTES_TO_PIECE))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:85: promote= PROMOTES_TO_PIECE
				{
				DebugLocation(118, 92);
				promote=(IToken)Match(input,PROMOTES_TO_PIECE,Follow._PROMOTES_TO_PIECE_in_individualMove773); 

				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(118, 113);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:113: (checkormate= CHECK |checkormate= MATE )?
			int alt16=3;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==CHECK))
			{
				alt16 = 1;
			}
			else if ((LA16_1==MATE))
			{
				alt16 = 2;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:114: checkormate= CHECK
				{
				DebugLocation(118, 125);
				checkormate=(IToken)Match(input,CHECK,Follow._CHECK_in_individualMove780); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:132: checkormate= MATE
				{
				DebugLocation(118, 143);
				checkormate=(IToken)Match(input,MATE,Follow._MATE_in_individualMove784); 

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(118, 151);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:151: ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			try
			{
				alt18 = dfa18.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:152: ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH
				{
				DebugLocation(118, 152);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:152: ( WS )+
				int cnt17=0;
				try { DebugEnterSubRule(17);
				while (true)
				{
					int alt17=2;
					try { DebugEnterDecision(17, false);
					int LA17_1 = input.LA(1);

					if ((LA17_1==WS))
					{
						alt17 = 1;
					}


					} finally { DebugExitDecision(17); }
					switch (alt17)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:152: WS
						{
						DebugLocation(118, 152);
						Match(input,WS,Follow._WS_in_individualMove789); 

						}
						break;

					default:
						if (cnt17 >= 1)
							goto loop17;

						EarlyExitException eee17 = new EarlyExitException( 17, input );
						DebugRecognitionException(eee17);
						throw eee17;
					}
					cnt17++;
				}
				loop17:
					;

				} finally { DebugExitSubRule(17); }

				DebugLocation(118, 172);
				annotation_glyph=(IToken)Match(input,NUMERIC_ANNOTATION_GLYPH,Follow._NUMERIC_ANNOTATION_GLYPH_in_individualMove794); 

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(118, 200);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:200: ( ( WS )+ annotationList )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			try
			{
				alt20 = dfa20.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:201: ( WS )+ annotationList
				{
				DebugLocation(118, 201);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:201: ( WS )+
				int cnt19=0;
				try { DebugEnterSubRule(19);
				while (true)
				{
					int alt19=2;
					try { DebugEnterDecision(19, false);
					int LA19_1 = input.LA(1);

					if ((LA19_1==WS))
					{
						alt19 = 1;
					}


					} finally { DebugExitDecision(19); }
					switch (alt19)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:118:201: WS
						{
						DebugLocation(118, 201);
						Match(input,WS,Follow._WS_in_individualMove799); 

						}
						break;

					default:
						if (cnt19 >= 1)
							goto loop19;

						EarlyExitException eee19 = new EarlyExitException( 19, input );
						DebugRecognitionException(eee19);
						throw eee19;
					}
					cnt19++;
				}
				loop19:
					;

				} finally { DebugExitSubRule(19); }

				DebugLocation(118, 205);
				PushFollow(Follow._annotationList_in_individualMove802);
				annotationList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(119, 1);

				if(PlayGame && m_variantDepth == 0)
					m_processor.ProcessMove(foo, promote == null ? "" : promote.Text, checkormate == null ? "" : checkormate.Text, annotation_glyph == null ? "" : annotation_glyph.Text);


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("individualMove", 9);
			LeaveRule("individualMove", 9);
			LeaveRule_individualMove();
		}
		DebugLocation(122, 2);
		} finally { DebugExitRule(GrammarFileName, "individualMove"); }
		return;

	}
	// $ANTLR end "individualMove"

	partial void EnterRule_moveList();
	partial void LeaveRule_moveList();
	// $ANTLR start "moveList"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:125:1: moveList : move ( ( WS )+ move )* ;
	[GrammarRule("moveList")]
	private void moveList()
	{
		EnterRule_moveList();
		EnterRule("moveList", 10);
		TraceIn("moveList", 10);
		try { DebugEnterRule(GrammarFileName, "moveList");
		DebugLocation(125, 28);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:125:10: ( move ( ( WS )+ move )* )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:125:12: move ( ( WS )+ move )*
			{
			DebugLocation(125, 12);
			PushFollow(Follow._move_in_moveList816);
			move();
			PopFollow();

			DebugLocation(125, 17);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:125:17: ( ( WS )+ move )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				try
				{
					alt22 = dfa22.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:125:18: ( WS )+ move
					{
					DebugLocation(125, 18);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:125:18: ( WS )+
					int cnt21=0;
					try { DebugEnterSubRule(21);
					while (true)
					{
						int alt21=2;
						try { DebugEnterDecision(21, false);
						int LA21_1 = input.LA(1);

						if ((LA21_1==WS))
						{
							alt21 = 1;
						}


						} finally { DebugExitDecision(21); }
						switch (alt21)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:125:18: WS
							{
							DebugLocation(125, 18);
							Match(input,WS,Follow._WS_in_moveList819); 

							}
							break;

						default:
							if (cnt21 >= 1)
								goto loop21;

							EarlyExitException eee21 = new EarlyExitException( 21, input );
							DebugRecognitionException(eee21);
							throw eee21;
						}
						cnt21++;
					}
					loop21:
						;

					} finally { DebugExitSubRule(21); }

					DebugLocation(125, 22);
					PushFollow(Follow._move_in_moveList822);
					move();
					PopFollow();


					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("moveList", 10);
			LeaveRule("moveList", 10);
			LeaveRule_moveList();
		}
		DebugLocation(125, 28);
		} finally { DebugExitRule(GrammarFileName, "moveList"); }
		return;

	}
	// $ANTLR end "moveList"

	partial void EnterRule_move();
	partial void LeaveRule_move();
	// $ANTLR start "move"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:1: move : MOVE_LABEL ( WS )* ( NO_MOVE ( WS )* )? individualMove ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )? ;
	[GrammarRule("move")]
	private void move()
	{
		EnterRule_move();
		EnterRule("move", 11);
		TraceIn("move", 11);
		try { DebugEnterRule(GrammarFileName, "move");
		DebugLocation(127, 105);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:6: ( MOVE_LABEL ( WS )* ( NO_MOVE ( WS )* )? individualMove ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )? )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:8: MOVE_LABEL ( WS )* ( NO_MOVE ( WS )* )? individualMove ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )?
			{
			DebugLocation(127, 8);
			Match(input,MOVE_LABEL,Follow._MOVE_LABEL_in_move833); 
			DebugLocation(127, 19);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:19: ( WS )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==WS))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:19: WS
					{
					DebugLocation(127, 19);
					Match(input,WS,Follow._WS_in_move835); 

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }

			DebugLocation(127, 23);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:23: ( NO_MOVE ( WS )* )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1==NO_MOVE))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:24: NO_MOVE ( WS )*
				{
				DebugLocation(127, 24);
				Match(input,NO_MOVE,Follow._NO_MOVE_in_move839); 
				DebugLocation(127, 32);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:32: ( WS )*
				try { DebugEnterSubRule(24);
				while (true)
				{
					int alt24=2;
					try { DebugEnterDecision(24, false);
					int LA24_1 = input.LA(1);

					if ((LA24_1==WS))
					{
						alt24 = 1;
					}


					} finally { DebugExitDecision(24); }
					switch ( alt24 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:32: WS
						{
						DebugLocation(127, 32);
						Match(input,WS,Follow._WS_in_move841); 

						}
						break;

					default:
						goto loop24;
					}
				}

				loop24:
					;

				} finally { DebugExitSubRule(24); }


				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(127, 38);
			PushFollow(Follow._individualMove_in_move846);
			individualMove();
			PopFollow();

			DebugLocation(127, 53);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:53: ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )?
			int alt31=2;
			try { DebugEnterSubRule(31);
			try { DebugEnterDecision(31, false);
			try
			{
				alt31 = dfa31.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:54: ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove
				{
				DebugLocation(127, 54);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:54: ( WS )+
				int cnt26=0;
				try { DebugEnterSubRule(26);
				while (true)
				{
					int alt26=2;
					try { DebugEnterDecision(26, false);
					int LA26_1 = input.LA(1);

					if ((LA26_1==WS))
					{
						alt26 = 1;
					}


					} finally { DebugExitDecision(26); }
					switch (alt26)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:54: WS
						{
						DebugLocation(127, 54);
						Match(input,WS,Follow._WS_in_move849); 

						}
						break;

					default:
						if (cnt26 >= 1)
							goto loop26;

						EarlyExitException eee26 = new EarlyExitException( 26, input );
						DebugRecognitionException(eee26);
						throw eee26;
					}
					cnt26++;
				}
				loop26:
					;

				} finally { DebugExitSubRule(26); }

				DebugLocation(127, 58);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:58: ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )?
				int alt30=2;
				try { DebugEnterSubRule(30);
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if (((LA30_1>=MOVE_LABEL && LA30_1<=NO_MOVE)||LA30_1==WS))
				{
					alt30 = 1;
				}
				} finally { DebugExitDecision(30); }
				switch (alt30)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:59: ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )*
					{
					DebugLocation(127, 59);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:59: ( MOVE_LABEL )?
					int alt27=2;
					try { DebugEnterSubRule(27);
					try { DebugEnterDecision(27, false);
					int LA27_1 = input.LA(1);

					if ((LA27_1==MOVE_LABEL))
					{
						alt27 = 1;
					}
					} finally { DebugExitDecision(27); }
					switch (alt27)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:59: MOVE_LABEL
						{
						DebugLocation(127, 59);
						Match(input,MOVE_LABEL,Follow._MOVE_LABEL_in_move853); 

						}
						break;

					}
					} finally { DebugExitSubRule(27); }

					DebugLocation(127, 71);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:71: ( WS )*
					try { DebugEnterSubRule(28);
					while (true)
					{
						int alt28=2;
						try { DebugEnterDecision(28, false);
						int LA28_1 = input.LA(1);

						if ((LA28_1==WS))
						{
							alt28 = 1;
						}


						} finally { DebugExitDecision(28); }
						switch ( alt28 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:71: WS
							{
							DebugLocation(127, 71);
							Match(input,WS,Follow._WS_in_move856); 

							}
							break;

						default:
							goto loop28;
						}
					}

					loop28:
						;

					} finally { DebugExitSubRule(28); }

					DebugLocation(127, 75);
					Match(input,NO_MOVE,Follow._NO_MOVE_in_move859); 
					DebugLocation(127, 83);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:83: ( WS )*
					try { DebugEnterSubRule(29);
					while (true)
					{
						int alt29=2;
						try { DebugEnterDecision(29, false);
						int LA29_1 = input.LA(1);

						if ((LA29_1==WS))
						{
							alt29 = 1;
						}


						} finally { DebugExitDecision(29); }
						switch ( alt29 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:127:83: WS
							{
							DebugLocation(127, 83);
							Match(input,WS,Follow._WS_in_move861); 

							}
							break;

						default:
							goto loop29;
						}
					}

					loop29:
						;

					} finally { DebugExitSubRule(29); }


					}
					break;

				}
				} finally { DebugExitSubRule(30); }

				DebugLocation(127, 89);
				PushFollow(Follow._individualMove_in_move866);
				individualMove();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(31); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("move", 11);
			LeaveRule("move", 11);
			LeaveRule_move();
		}
		DebugLocation(127, 105);
		} finally { DebugExitRule(GrammarFileName, "move"); }
		return;

	}
	// $ANTLR end "move"

	partial void EnterRule_compulsoryTag();
	partial void LeaveRule_compulsoryTag();
	// $ANTLR start "compulsoryTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:1: compulsoryTag : ( eventTag | siteTag | dateTag | roundTag | blackTag | whiteTag | resultTag ) ;
	[GrammarRule("compulsoryTag")]
	private void compulsoryTag()
	{
		EnterRule_compulsoryTag();
		EnterRule("compulsoryTag", 12);
		TraceIn("compulsoryTag", 12);
		try { DebugEnterRule(GrammarFileName, "compulsoryTag");
		DebugLocation(128, 92);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:15: ( ( eventTag | siteTag | dateTag | roundTag | blackTag | whiteTag | resultTag ) )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:17: ( eventTag | siteTag | dateTag | roundTag | blackTag | whiteTag | resultTag )
			{
			DebugLocation(128, 17);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:17: ( eventTag | siteTag | dateTag | roundTag | blackTag | whiteTag | resultTag )
			int alt32=7;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_1 = input.LA(1);

			if ((LA32_1==LEFT_TAG))
			{
				switch (input.LA(2))
				{
				case EVENT:
					{
					alt32 = 1;
					}
					break;
				case SITE:
					{
					alt32 = 2;
					}
					break;
				case DATE:
					{
					alt32 = 3;
					}
					break;
				case ROUND:
					{
					alt32 = 4;
					}
					break;
				case BLACK:
					{
					alt32 = 5;
					}
					break;
				case WHITE:
					{
					alt32 = 6;
					}
					break;
				case RESULT:
					{
					alt32 = 7;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 32, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 32, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:18: eventTag
				{
				DebugLocation(128, 18);
				PushFollow(Follow._eventTag_in_compulsoryTag877);
				eventTag();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:29: siteTag
				{
				DebugLocation(128, 29);
				PushFollow(Follow._siteTag_in_compulsoryTag881);
				siteTag();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:39: dateTag
				{
				DebugLocation(128, 39);
				PushFollow(Follow._dateTag_in_compulsoryTag885);
				dateTag();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:49: roundTag
				{
				DebugLocation(128, 49);
				PushFollow(Follow._roundTag_in_compulsoryTag889);
				roundTag();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:60: blackTag
				{
				DebugLocation(128, 60);
				PushFollow(Follow._blackTag_in_compulsoryTag893);
				blackTag();
				PopFollow();


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:71: whiteTag
				{
				DebugLocation(128, 71);
				PushFollow(Follow._whiteTag_in_compulsoryTag897);
				whiteTag();
				PopFollow();


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:128:82: resultTag
				{
				DebugLocation(128, 82);
				PushFollow(Follow._resultTag_in_compulsoryTag901);
				resultTag();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(32); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("compulsoryTag", 12);
			LeaveRule("compulsoryTag", 12);
			LeaveRule_compulsoryTag();
		}
		DebugLocation(128, 92);
		} finally { DebugExitRule(GrammarFileName, "compulsoryTag"); }
		return;

	}
	// $ANTLR end "compulsoryTag"

	partial void EnterRule_blockComment();
	partial void LeaveRule_blockComment();
	// $ANTLR start "blockComment"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:130:1: blockComment : comment= BLOCK_COMMENT ;
	[GrammarRule("blockComment")]
	private void blockComment()
	{
		EnterRule_blockComment();
		EnterRule("blockComment", 13);
		TraceIn("blockComment", 13);
		IToken comment = default(IToken);

		try { DebugEnterRule(GrammarFileName, "blockComment");
		DebugLocation(130, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:130:14: (comment= BLOCK_COMMENT )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:130:16: comment= BLOCK_COMMENT
			{
			DebugLocation(130, 23);
			comment=(IToken)Match(input,BLOCK_COMMENT,Follow._BLOCK_COMMENT_in_blockComment913); 
			DebugLocation(131, 1);

				// Console.WriteLine(comment.Text);


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("blockComment", 13);
			LeaveRule("blockComment", 13);
			LeaveRule_blockComment();
		}
		DebugLocation(133, 1);
		} finally { DebugExitRule(GrammarFileName, "blockComment"); }
		return;

	}
	// $ANTLR end "blockComment"

	partial void EnterRule_enterVariant();
	partial void LeaveRule_enterVariant();
	// $ANTLR start "enterVariant"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:135:1: enterVariant : LEFT_BRACKET ;
	[GrammarRule("enterVariant")]
	private void enterVariant()
	{
		EnterRule_enterVariant();
		EnterRule("enterVariant", 14);
		TraceIn("enterVariant", 14);
		try { DebugEnterRule(GrammarFileName, "enterVariant");
		DebugLocation(135, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:135:14: ( LEFT_BRACKET )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:135:16: LEFT_BRACKET
			{
			DebugLocation(135, 16);
			Match(input,LEFT_BRACKET,Follow._LEFT_BRACKET_in_enterVariant923); 
			DebugLocation(136, 1);

				m_variantDepth++;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("enterVariant", 14);
			LeaveRule("enterVariant", 14);
			LeaveRule_enterVariant();
		}
		DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "enterVariant"); }
		return;

	}
	// $ANTLR end "enterVariant"

	partial void EnterRule_leaveVariant();
	partial void LeaveRule_leaveVariant();
	// $ANTLR start "leaveVariant"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:140:1: leaveVariant : RIGHT_BRACKET ;
	[GrammarRule("leaveVariant")]
	private void leaveVariant()
	{
		EnterRule_leaveVariant();
		EnterRule("leaveVariant", 15);
		TraceIn("leaveVariant", 15);
		try { DebugEnterRule(GrammarFileName, "leaveVariant");
		DebugLocation(140, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:140:14: ( RIGHT_BRACKET )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:140:16: RIGHT_BRACKET
			{
			DebugLocation(140, 16);
			Match(input,RIGHT_BRACKET,Follow._RIGHT_BRACKET_in_leaveVariant933); 
			DebugLocation(141, 1);

				m_variantDepth--;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("leaveVariant", 15);
			LeaveRule("leaveVariant", 15);
			LeaveRule_leaveVariant();
		}
		DebugLocation(143, 1);
		} finally { DebugExitRule(GrammarFileName, "leaveVariant"); }
		return;

	}
	// $ANTLR end "leaveVariant"

	partial void EnterRule_variantLine();
	partial void LeaveRule_variantLine();
	// $ANTLR start "variantLine"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:145:1: variantLine : enterVariant ( moveList | variantLine )* ( WS )* leaveVariant ;
	[GrammarRule("variantLine")]
	private void variantLine()
	{
		EnterRule_variantLine();
		EnterRule("variantLine", 16);
		TraceIn("variantLine", 16);
		try { DebugEnterRule(GrammarFileName, "variantLine");
		DebugLocation(145, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:145:13: ( enterVariant ( moveList | variantLine )* ( WS )* leaveVariant )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:145:15: enterVariant ( moveList | variantLine )* ( WS )* leaveVariant
			{
			DebugLocation(145, 15);
			PushFollow(Follow._enterVariant_in_variantLine943);
			enterVariant();
			PopFollow();

			DebugLocation(145, 28);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:145:28: ( moveList | variantLine )*
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=3;
				try { DebugEnterDecision(33, false);
				int LA33_1 = input.LA(1);

				if ((LA33_1==MOVE_LABEL))
				{
					alt33 = 1;
				}
				else if ((LA33_1==LEFT_BRACKET))
				{
					alt33 = 2;
				}


				} finally { DebugExitDecision(33); }
				switch ( alt33 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:145:29: moveList
					{
					DebugLocation(145, 29);
					PushFollow(Follow._moveList_in_variantLine946);
					moveList();
					PopFollow();


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:145:40: variantLine
					{
					DebugLocation(145, 40);
					PushFollow(Follow._variantLine_in_variantLine950);
					variantLine();
					PopFollow();


					}
					break;

				default:
					goto loop33;
				}
			}

			loop33:
				;

			} finally { DebugExitSubRule(33); }

			DebugLocation(145, 54);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:145:54: ( WS )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if ((LA34_1==WS))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:145:54: WS
					{
					DebugLocation(145, 54);
					Match(input,WS,Follow._WS_in_variantLine954); 

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }

			DebugLocation(145, 58);
			PushFollow(Follow._leaveVariant_in_variantLine957);
			leaveVariant();
			PopFollow();

			DebugLocation(146, 1);

				// Console.WriteLine(actual_text.Text);


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variantLine", 16);
			LeaveRule("variantLine", 16);
			LeaveRule_variantLine();
		}
		DebugLocation(148, 1);
		} finally { DebugExitRule(GrammarFileName, "variantLine"); }
		return;

	}
	// $ANTLR end "variantLine"

	partial void EnterRule_eventTag();
	partial void LeaveRule_eventTag();
	// $ANTLR start "eventTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:150:1: eventTag : LEFT_TAG EVENT ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("eventTag")]
	private void eventTag()
	{
		EnterRule_eventTag();
		EnterRule("eventTag", 17);
		TraceIn("eventTag", 17);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "eventTag");
		DebugLocation(150, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:150:10: ( LEFT_TAG EVENT ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:150:12: LEFT_TAG EVENT ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(150, 12);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_eventTag967); 
			DebugLocation(150, 21);
			Match(input,EVENT,Follow._EVENT_in_eventTag969); 
			DebugLocation(150, 27);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:150:27: ( WS )+
			int cnt35=0;
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1==WS))
				{
					alt35 = 1;
				}


				} finally { DebugExitDecision(35); }
				switch (alt35)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:150:27: WS
					{
					DebugLocation(150, 27);
					Match(input,WS,Follow._WS_in_eventTag971); 

					}
					break;

				default:
					if (cnt35 >= 1)
						goto loop35;

					EarlyExitException eee35 = new EarlyExitException( 35, input );
					DebugRecognitionException(eee35);
					throw eee35;
				}
				cnt35++;
			}
			loop35:
				;

			} finally { DebugExitSubRule(35); }

			DebugLocation(150, 34);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_eventTag976); 
			DebugLocation(150, 49);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_eventTag978); 
			DebugLocation(151, 1);
			 
				Event = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("eventTag", 17);
			LeaveRule("eventTag", 17);
			LeaveRule_eventTag();
		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "eventTag"); }
		return;

	}
	// $ANTLR end "eventTag"

	partial void EnterRule_siteTag();
	partial void LeaveRule_siteTag();
	// $ANTLR start "siteTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:155:1: siteTag : LEFT_TAG SITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("siteTag")]
	private void siteTag()
	{
		EnterRule_siteTag();
		EnterRule("siteTag", 18);
		TraceIn("siteTag", 18);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "siteTag");
		DebugLocation(155, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:155:9: ( LEFT_TAG SITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:155:11: LEFT_TAG SITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(155, 11);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_siteTag989); 
			DebugLocation(155, 20);
			Match(input,SITE,Follow._SITE_in_siteTag991); 
			DebugLocation(155, 25);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:155:25: ( WS )+
			int cnt36=0;
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if ((LA36_1==WS))
				{
					alt36 = 1;
				}


				} finally { DebugExitDecision(36); }
				switch (alt36)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:155:25: WS
					{
					DebugLocation(155, 25);
					Match(input,WS,Follow._WS_in_siteTag993); 

					}
					break;

				default:
					if (cnt36 >= 1)
						goto loop36;

					EarlyExitException eee36 = new EarlyExitException( 36, input );
					DebugRecognitionException(eee36);
					throw eee36;
				}
				cnt36++;
			}
			loop36:
				;

			} finally { DebugExitSubRule(36); }

			DebugLocation(155, 32);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_siteTag998); 
			DebugLocation(155, 47);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_siteTag1000); 
			DebugLocation(156, 1);
			 
				Site = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("siteTag", 18);
			LeaveRule("siteTag", 18);
			LeaveRule_siteTag();
		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "siteTag"); }
		return;

	}
	// $ANTLR end "siteTag"

	partial void EnterRule_dateTag();
	partial void LeaveRule_dateTag();
	// $ANTLR start "dateTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:160:1: dateTag : LEFT_TAG DATE ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("dateTag")]
	private void dateTag()
	{
		EnterRule_dateTag();
		EnterRule("dateTag", 19);
		TraceIn("dateTag", 19);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "dateTag");
		DebugLocation(160, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:160:9: ( LEFT_TAG DATE ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:160:11: LEFT_TAG DATE ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(160, 11);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_dateTag1011); 
			DebugLocation(160, 20);
			Match(input,DATE,Follow._DATE_in_dateTag1013); 
			DebugLocation(160, 25);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:160:25: ( WS )+
			int cnt37=0;
			try { DebugEnterSubRule(37);
			while (true)
			{
				int alt37=2;
				try { DebugEnterDecision(37, false);
				int LA37_1 = input.LA(1);

				if ((LA37_1==WS))
				{
					alt37 = 1;
				}


				} finally { DebugExitDecision(37); }
				switch (alt37)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:160:25: WS
					{
					DebugLocation(160, 25);
					Match(input,WS,Follow._WS_in_dateTag1015); 

					}
					break;

				default:
					if (cnt37 >= 1)
						goto loop37;

					EarlyExitException eee37 = new EarlyExitException( 37, input );
					DebugRecognitionException(eee37);
					throw eee37;
				}
				cnt37++;
			}
			loop37:
				;

			} finally { DebugExitSubRule(37); }

			DebugLocation(160, 32);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_dateTag1020); 
			DebugLocation(160, 47);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_dateTag1022); 
			DebugLocation(161, 1);
			 
				Date = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("dateTag", 19);
			LeaveRule("dateTag", 19);
			LeaveRule_dateTag();
		}
		DebugLocation(163, 1);
		} finally { DebugExitRule(GrammarFileName, "dateTag"); }
		return;

	}
	// $ANTLR end "dateTag"

	partial void EnterRule_roundTag();
	partial void LeaveRule_roundTag();
	// $ANTLR start "roundTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:165:1: roundTag : LEFT_TAG ROUND ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("roundTag")]
	private void roundTag()
	{
		EnterRule_roundTag();
		EnterRule("roundTag", 20);
		TraceIn("roundTag", 20);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "roundTag");
		DebugLocation(165, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:165:10: ( LEFT_TAG ROUND ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:165:12: LEFT_TAG ROUND ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(165, 12);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_roundTag1033); 
			DebugLocation(165, 21);
			Match(input,ROUND,Follow._ROUND_in_roundTag1035); 
			DebugLocation(165, 27);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:165:27: ( WS )+
			int cnt38=0;
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=2;
				try { DebugEnterDecision(38, false);
				int LA38_1 = input.LA(1);

				if ((LA38_1==WS))
				{
					alt38 = 1;
				}


				} finally { DebugExitDecision(38); }
				switch (alt38)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:165:27: WS
					{
					DebugLocation(165, 27);
					Match(input,WS,Follow._WS_in_roundTag1037); 

					}
					break;

				default:
					if (cnt38 >= 1)
						goto loop38;

					EarlyExitException eee38 = new EarlyExitException( 38, input );
					DebugRecognitionException(eee38);
					throw eee38;
				}
				cnt38++;
			}
			loop38:
				;

			} finally { DebugExitSubRule(38); }

			DebugLocation(165, 34);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_roundTag1042); 
			DebugLocation(165, 49);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_roundTag1044); 
			DebugLocation(166, 1);
			 
				Round = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("roundTag", 20);
			LeaveRule("roundTag", 20);
			LeaveRule_roundTag();
		}
		DebugLocation(168, 1);
		} finally { DebugExitRule(GrammarFileName, "roundTag"); }
		return;

	}
	// $ANTLR end "roundTag"

	partial void EnterRule_blackTag();
	partial void LeaveRule_blackTag();
	// $ANTLR start "blackTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:170:1: blackTag : LEFT_TAG BLACK ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("blackTag")]
	private void blackTag()
	{
		EnterRule_blackTag();
		EnterRule("blackTag", 21);
		TraceIn("blackTag", 21);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "blackTag");
		DebugLocation(170, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:170:10: ( LEFT_TAG BLACK ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:170:12: LEFT_TAG BLACK ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(170, 12);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_blackTag1055); 
			DebugLocation(170, 22);
			Match(input,BLACK,Follow._BLACK_in_blackTag1058); 
			DebugLocation(170, 28);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:170:28: ( WS )+
			int cnt39=0;
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1==WS))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch (alt39)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:170:28: WS
					{
					DebugLocation(170, 28);
					Match(input,WS,Follow._WS_in_blackTag1060); 

					}
					break;

				default:
					if (cnt39 >= 1)
						goto loop39;

					EarlyExitException eee39 = new EarlyExitException( 39, input );
					DebugRecognitionException(eee39);
					throw eee39;
				}
				cnt39++;
			}
			loop39:
				;

			} finally { DebugExitSubRule(39); }

			DebugLocation(170, 35);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_blackTag1065); 
			DebugLocation(170, 50);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_blackTag1067); 
			DebugLocation(171, 1);
			 
				Black = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("blackTag", 21);
			LeaveRule("blackTag", 21);
			LeaveRule_blackTag();
		}
		DebugLocation(173, 1);
		} finally { DebugExitRule(GrammarFileName, "blackTag"); }
		return;

	}
	// $ANTLR end "blackTag"

	partial void EnterRule_whiteTag();
	partial void LeaveRule_whiteTag();
	// $ANTLR start "whiteTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:175:1: whiteTag : LEFT_TAG WHITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("whiteTag")]
	private void whiteTag()
	{
		EnterRule_whiteTag();
		EnterRule("whiteTag", 22);
		TraceIn("whiteTag", 22);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "whiteTag");
		DebugLocation(175, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:175:10: ( LEFT_TAG WHITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:175:12: LEFT_TAG WHITE ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(175, 12);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_whiteTag1078); 
			DebugLocation(175, 21);
			Match(input,WHITE,Follow._WHITE_in_whiteTag1080); 
			DebugLocation(175, 27);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:175:27: ( WS )+
			int cnt40=0;
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==WS))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch (alt40)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:175:27: WS
					{
					DebugLocation(175, 27);
					Match(input,WS,Follow._WS_in_whiteTag1082); 

					}
					break;

				default:
					if (cnt40 >= 1)
						goto loop40;

					EarlyExitException eee40 = new EarlyExitException( 40, input );
					DebugRecognitionException(eee40);
					throw eee40;
				}
				cnt40++;
			}
			loop40:
				;

			} finally { DebugExitSubRule(40); }

			DebugLocation(175, 34);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_whiteTag1087); 
			DebugLocation(175, 49);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_whiteTag1089); 
			DebugLocation(176, 1);
			 
				White = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\""); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whiteTag", 22);
			LeaveRule("whiteTag", 22);
			LeaveRule_whiteTag();
		}
		DebugLocation(178, 1);
		} finally { DebugExitRule(GrammarFileName, "whiteTag"); }
		return;

	}
	// $ANTLR end "whiteTag"

	partial void EnterRule_resultTag();
	partial void LeaveRule_resultTag();
	// $ANTLR start "resultTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:180:1: resultTag : LEFT_TAG RESULT ( WS )+ bar= GAME_RESULT RIGHT_TAG ;
	[GrammarRule("resultTag")]
	private void resultTag()
	{
		EnterRule_resultTag();
		EnterRule("resultTag", 23);
		TraceIn("resultTag", 23);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "resultTag");
		DebugLocation(180, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:180:11: ( LEFT_TAG RESULT ( WS )+ bar= GAME_RESULT RIGHT_TAG )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:180:13: LEFT_TAG RESULT ( WS )+ bar= GAME_RESULT RIGHT_TAG
			{
			DebugLocation(180, 13);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_resultTag1100); 
			DebugLocation(180, 22);
			Match(input,RESULT,Follow._RESULT_in_resultTag1102); 
			DebugLocation(180, 29);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:180:29: ( WS )+
			int cnt41=0;
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=2;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==WS))
				{
					alt41 = 1;
				}


				} finally { DebugExitDecision(41); }
				switch (alt41)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:180:29: WS
					{
					DebugLocation(180, 29);
					Match(input,WS,Follow._WS_in_resultTag1104); 

					}
					break;

				default:
					if (cnt41 >= 1)
						goto loop41;

					EarlyExitException eee41 = new EarlyExitException( 41, input );
					DebugRecognitionException(eee41);
					throw eee41;
				}
				cnt41++;
			}
			loop41:
				;

			} finally { DebugExitSubRule(41); }

			DebugLocation(180, 36);
			bar=(IToken)Match(input,GAME_RESULT,Follow._GAME_RESULT_in_resultTag1109); 
			DebugLocation(180, 49);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_resultTag1111); 
			DebugLocation(181, 1);

				Result = bar.Text.Trim(c_doubleQuote);


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("resultTag", 23);
			LeaveRule("resultTag", 23);
			LeaveRule_resultTag();
		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "resultTag"); }
		return;

	}
	// $ANTLR end "resultTag"

	partial void EnterRule_optionalTag();
	partial void LeaveRule_optionalTag();
	// $ANTLR start "optionalTag"
	// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:185:1: optionalTag : LEFT_TAG (foo= TAG_NAME )+ ( WS )+ bar= QUOTED_STRING RIGHT_TAG ;
	[GrammarRule("optionalTag")]
	private void optionalTag()
	{
		EnterRule_optionalTag();
		EnterRule("optionalTag", 24);
		TraceIn("optionalTag", 24);
		IToken foo = default(IToken);
		IToken bar = default(IToken);

		try { DebugEnterRule(GrammarFileName, "optionalTag");
		DebugLocation(185, 1);
		try
		{
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:185:13: ( LEFT_TAG (foo= TAG_NAME )+ ( WS )+ bar= QUOTED_STRING RIGHT_TAG )
			DebugEnterAlt(1);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:185:15: LEFT_TAG (foo= TAG_NAME )+ ( WS )+ bar= QUOTED_STRING RIGHT_TAG
			{
			DebugLocation(185, 15);
			Match(input,LEFT_TAG,Follow._LEFT_TAG_in_optionalTag1121); 
			DebugLocation(185, 27);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:185:27: (foo= TAG_NAME )+
			int cnt42=0;
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_1 = input.LA(1);

				if ((LA42_1==TAG_NAME))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch (alt42)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:185:27: foo= TAG_NAME
					{
					DebugLocation(185, 27);
					foo=(IToken)Match(input,TAG_NAME,Follow._TAG_NAME_in_optionalTag1125); 

					}
					break;

				default:
					if (cnt42 >= 1)
						goto loop42;

					EarlyExitException eee42 = new EarlyExitException( 42, input );
					DebugRecognitionException(eee42);
					throw eee42;
				}
				cnt42++;
			}
			loop42:
				;

			} finally { DebugExitSubRule(42); }

			DebugLocation(185, 38);
			// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:185:38: ( WS )+
			int cnt43=0;
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1==WS))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\james.gilmore\\Chess\\redchess\\PgnParser\\Pgn.g:185:38: WS
					{
					DebugLocation(185, 38);
					Match(input,WS,Follow._WS_in_optionalTag1128); 

					}
					break;

				default:
					if (cnt43 >= 1)
						goto loop43;

					EarlyExitException eee43 = new EarlyExitException( 43, input );
					DebugRecognitionException(eee43);
					throw eee43;
				}
				cnt43++;
			}
			loop43:
				;

			} finally { DebugExitSubRule(43); }

			DebugLocation(185, 45);
			bar=(IToken)Match(input,QUOTED_STRING,Follow._QUOTED_STRING_in_optionalTag1133); 
			DebugLocation(185, 60);
			Match(input,RIGHT_TAG,Follow._RIGHT_TAG_in_optionalTag1135); 
			DebugLocation(186, 1);

				string trimmedText = bar.Text.Trim(c_doubleQuote).Replace("\"\"", "\"");
			    m_optionalTags.Add(foo.Text, trimmedText); 
				if(foo.Text == "FEN")
				{
				    // rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1
					m_processor.DoFen(trimmedText);
				}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("optionalTag", 24);
			LeaveRule("optionalTag", 24);
			LeaveRule_optionalTag();
		}
		DebugLocation(194, 1);
		} finally { DebugExitRule(GrammarFileName, "optionalTag"); }
		return;

	}
	// $ANTLR end "optionalTag"
	#endregion Rules


	#region DFA
	private DFA6 dfa6;
	private DFA14 dfa14;
	private DFA18 dfa18;
	private DFA20 dfa20;
	private DFA22 dfa22;
	private DFA31 dfa31;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa6 = new DFA6( this );
		dfa14 = new DFA14( this );
		dfa18 = new DFA18( this );
		dfa20 = new DFA20( this );
		dfa22 = new DFA22( this );
		dfa31 = new DFA31( this );
	}

	private class DFA6 : DFA
	{
		private const string DFA6_eotS =
			"\x26\xFFFF";
		private const string DFA6_eofS =
			"\x1\xFFFF\x1\x3\x2\xFFFF\x1\x3\x21\xFFFF";
		private const string DFA6_minS =
			"\x1\x12\x1\xE\x2\xFFFF\x1\xE\x1\x4\x7\x2C\x1\x26\x6\x1D\x1\xD\x1\x1D"+
			"\x8\x21\x8\xFFFF";
		private const string DFA6_maxS =
			"\x2\x2C\x2\xFFFF\x1\x2C\x1\x2B\x10\x2C\x8\x21\x8\xFFFF";
		private const string DFA6_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1A\xFFFF\x8\x1";
		private const string DFA6_specialS =
			"\x26\xFFFF}>";
		private static readonly string[] DFA6_transitionS =
			{
				"\x1\x2\x19\xFFFF\x1\x1",
				"\x1\x3\x3\xFFFF\x1\x5\x2\xFFFF\x1\x3\x16\xFFFF\x1\x4",
				"",
				"",
				"\x1\x3\x3\xFFFF\x1\x5\x2\xFFFF\x1\x3\x16\xFFFF\x1\x4",
				"\x1\xA\x6\xFFFF\x1\x8\x1\x6\x11\xFFFF\x1\xC\x3\xFFFF\x1\x9\x1\xFFFF"+
				"\x1\x7\x1\xFFFF\x1\xD\x4\xFFFF\x1\xB",
				"\x1\xE",
				"\x1\xF",
				"\x1\x10",
				"\x1\x11",
				"\x1\x12",
				"\x1\x13",
				"\x1\x14",
				"\x1\xD\x5\xFFFF\x1\x15",
				"\x1\x16\xE\xFFFF\x1\xE",
				"\x1\x17\xE\xFFFF\x1\xF",
				"\x1\x18\xE\xFFFF\x1\x10",
				"\x1\x19\xE\xFFFF\x1\x11",
				"\x1\x1A\xE\xFFFF\x1\x12",
				"\x1\x1B\xE\xFFFF\x1\x13",
				"\x1\x1C\x1E\xFFFF\x1\x14",
				"\x1\x1D\xE\xFFFF\x1\x15",
				"\x1\x1E",
				"\x1\x1F",
				"\x1\x20",
				"\x1\x21",
				"\x1\x22",
				"\x1\x23",
				"\x1\x24",
				"\x1\x25",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA6_eot = DFA.UnpackEncodedString(DFA6_eotS);
		private static readonly short[] DFA6_eof = DFA.UnpackEncodedString(DFA6_eofS);
		private static readonly char[] DFA6_min = DFA.UnpackEncodedStringToUnsignedChars(DFA6_minS);
		private static readonly char[] DFA6_max = DFA.UnpackEncodedStringToUnsignedChars(DFA6_maxS);
		private static readonly short[] DFA6_accept = DFA.UnpackEncodedString(DFA6_acceptS);
		private static readonly short[] DFA6_special = DFA.UnpackEncodedString(DFA6_specialS);
		private static readonly short[][] DFA6_transition;

		static DFA6()
		{
			int numStates = DFA6_transitionS.Length;
			DFA6_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA6_transition[i] = DFA.UnpackEncodedString(DFA6_transitionS[i]);
			}
		}

		public DFA6( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 6;
			this.eot = DFA6_eot;
			this.eof = DFA6_eof;
			this.min = DFA6_min;
			this.max = DFA6_max;
			this.accept = DFA6_accept;
			this.special = DFA6_special;
			this.transition = DFA6_transition;
		}

		public override string Description { get { return "()* loopback of 105:46: ( ( WS )* ( optionalTag | compulsoryTag ) )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA14 : DFA
	{
		private const string DFA14_eotS =
			"\x5\xFFFF";
		private const string DFA14_eofS =
			"\x2\x2\x1\xFFFF\x1\x2\x1\xFFFF";
		private const string DFA14_minS =
			"\x1\xE\x1\x5\x1\xFFFF\x1\x5\x1\xFFFF";
		private const string DFA14_maxS =
			"\x2\x2C\x1\xFFFF\x1\x2C\x1\xFFFF";
		private const string DFA14_acceptS =
			"\x2\xFFFF\x1\x2\x1\xFFFF\x1\x1";
		private const string DFA14_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA14_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x1\x4\x3\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x4\x1\xFFFF\x1\x2\x2\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x3",
				"",
				"\x1\x4\x3\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x4\x1\xFFFF\x1\x2\x2\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x3",
				""
			};

		private static readonly short[] DFA14_eot = DFA.UnpackEncodedString(DFA14_eotS);
		private static readonly short[] DFA14_eof = DFA.UnpackEncodedString(DFA14_eofS);
		private static readonly char[] DFA14_min = DFA.UnpackEncodedStringToUnsignedChars(DFA14_minS);
		private static readonly char[] DFA14_max = DFA.UnpackEncodedStringToUnsignedChars(DFA14_maxS);
		private static readonly short[] DFA14_accept = DFA.UnpackEncodedString(DFA14_acceptS);
		private static readonly short[] DFA14_special = DFA.UnpackEncodedString(DFA14_specialS);
		private static readonly short[][] DFA14_transition;

		static DFA14()
		{
			int numStates = DFA14_transitionS.Length;
			DFA14_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA14_transition[i] = DFA.UnpackEncodedString(DFA14_transitionS[i]);
			}
		}

		public DFA14( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 14;
			this.eot = DFA14_eot;
			this.eof = DFA14_eof;
			this.min = DFA14_min;
			this.max = DFA14_max;
			this.accept = DFA14_accept;
			this.special = DFA14_special;
			this.transition = DFA14_transition;
		}

		public override string Description { get { return "()* loopback of 117:29: ( ( WS )+ annotation )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA18 : DFA
	{
		private const string DFA18_eotS =
			"\x5\xFFFF";
		private const string DFA18_eofS =
			"\x2\x2\x2\xFFFF\x1\x2";
		private const string DFA18_minS =
			"\x1\xE\x1\x5\x2\xFFFF\x1\x5";
		private const string DFA18_maxS =
			"\x2\x2C\x2\xFFFF\x1\x2C";
		private const string DFA18_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA18_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA18_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x4\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2"+
				"\x1\x3\x1\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4",
				"",
				"",
				"\x4\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x2\x2"+
				"\x1\x3\x1\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4"
			};

		private static readonly short[] DFA18_eot = DFA.UnpackEncodedString(DFA18_eotS);
		private static readonly short[] DFA18_eof = DFA.UnpackEncodedString(DFA18_eofS);
		private static readonly char[] DFA18_min = DFA.UnpackEncodedStringToUnsignedChars(DFA18_minS);
		private static readonly char[] DFA18_max = DFA.UnpackEncodedStringToUnsignedChars(DFA18_maxS);
		private static readonly short[] DFA18_accept = DFA.UnpackEncodedString(DFA18_acceptS);
		private static readonly short[] DFA18_special = DFA.UnpackEncodedString(DFA18_specialS);
		private static readonly short[][] DFA18_transition;

		static DFA18()
		{
			int numStates = DFA18_transitionS.Length;
			DFA18_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA18_transition[i] = DFA.UnpackEncodedString(DFA18_transitionS[i]);
			}
		}

		public DFA18( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 18;
			this.eot = DFA18_eot;
			this.eof = DFA18_eof;
			this.min = DFA18_min;
			this.max = DFA18_max;
			this.accept = DFA18_accept;
			this.special = DFA18_special;
			this.transition = DFA18_transition;
		}

		public override string Description { get { return "118:151: ( ( WS )+ annotation_glyph= NUMERIC_ANNOTATION_GLYPH )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA20 : DFA
	{
		private const string DFA20_eotS =
			"\x5\xFFFF";
		private const string DFA20_eofS =
			"\x2\x2\x2\xFFFF\x1\x2";
		private const string DFA20_minS =
			"\x1\xE\x1\x5\x2\xFFFF\x1\x5";
		private const string DFA20_maxS =
			"\x2\x2C\x2\xFFFF\x1\x2C";
		private const string DFA20_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA20_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA20_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x1\x3\x3\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x1\x2\x2\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4",
				"",
				"",
				"\x1\x3\x3\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x1\x2\x2\xFFFF"+
				"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4"
			};

		private static readonly short[] DFA20_eot = DFA.UnpackEncodedString(DFA20_eotS);
		private static readonly short[] DFA20_eof = DFA.UnpackEncodedString(DFA20_eofS);
		private static readonly char[] DFA20_min = DFA.UnpackEncodedStringToUnsignedChars(DFA20_minS);
		private static readonly char[] DFA20_max = DFA.UnpackEncodedStringToUnsignedChars(DFA20_maxS);
		private static readonly short[] DFA20_accept = DFA.UnpackEncodedString(DFA20_acceptS);
		private static readonly short[] DFA20_special = DFA.UnpackEncodedString(DFA20_specialS);
		private static readonly short[][] DFA20_transition;

		static DFA20()
		{
			int numStates = DFA20_transitionS.Length;
			DFA20_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA20_transition[i] = DFA.UnpackEncodedString(DFA20_transitionS[i]);
			}
		}

		public DFA20( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 20;
			this.eot = DFA20_eot;
			this.eof = DFA20_eof;
			this.min = DFA20_min;
			this.max = DFA20_max;
			this.accept = DFA20_accept;
			this.special = DFA20_special;
			this.transition = DFA20_transition;
		}

		public override string Description { get { return "118:200: ( ( WS )+ annotationList )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA22 : DFA
	{
		private const string DFA22_eotS =
			"\x4\xFFFF";
		private const string DFA22_eofS =
			"\x2\x2\x2\xFFFF";
		private const string DFA22_minS =
			"\x2\xE\x2\xFFFF";
		private const string DFA22_maxS =
			"\x2\x2C\x2\xFFFF";
		private const string DFA22_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA22_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA22_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x1\x2\x3\xFFFF\x1\x2\x2\xFFFF\x1\x3\x9\xFFFF\x1\x2\xC\xFFFF\x1\x1",
				"",
				""
			};

		private static readonly short[] DFA22_eot = DFA.UnpackEncodedString(DFA22_eotS);
		private static readonly short[] DFA22_eof = DFA.UnpackEncodedString(DFA22_eofS);
		private static readonly char[] DFA22_min = DFA.UnpackEncodedStringToUnsignedChars(DFA22_minS);
		private static readonly char[] DFA22_max = DFA.UnpackEncodedStringToUnsignedChars(DFA22_maxS);
		private static readonly short[] DFA22_accept = DFA.UnpackEncodedString(DFA22_acceptS);
		private static readonly short[] DFA22_special = DFA.UnpackEncodedString(DFA22_specialS);
		private static readonly short[][] DFA22_transition;

		static DFA22()
		{
			int numStates = DFA22_transitionS.Length;
			DFA22_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA22_transition[i] = DFA.UnpackEncodedString(DFA22_transitionS[i]);
			}
		}

		public DFA22( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 22;
			this.eot = DFA22_eot;
			this.eof = DFA22_eof;
			this.min = DFA22_min;
			this.max = DFA22_max;
			this.accept = DFA22_accept;
			this.special = DFA22_special;
			this.transition = DFA22_transition;
		}

		public override string Description { get { return "()* loopback of 125:17: ( ( WS )+ move )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA31 : DFA
	{
		private const string DFA31_eotS =
			"\xA\xFFFF";
		private const string DFA31_eofS =
			"\x2\x2\x2\xFFFF\x1\x2\x5\xFFFF";
		private const string DFA31_minS =
			"\x1\xE\x1\x6\x1\xFFFF\x2\x6\x1\xFFFF\x3\x6\x1\xFFFF";
		private const string DFA31_maxS =
			"\x2\x2C\x1\xFFFF\x2\x2C\x1\xFFFF\x3\x2C\x1\xFFFF";
		private const string DFA31_acceptS =
			"\x2\xFFFF\x1\x2\x2\xFFFF\x1\x1\x3\xFFFF\x1\x1";
		private const string DFA31_specialS =
			"\xA\xFFFF}>";
		private static readonly string[] DFA31_transitionS =
			{
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x9\xFFFF\x1\x2\xC"+
				"\xFFFF\x1\x1",
				"\x3\x5\x5\xFFFF\x1\x2\x3\xFFFF\x1\x2\x2\xFFFF\x1\x3\x1\x5\x2\xFFFF"+
				"\x1\x5\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4",
				"",
				"\x3\x2\xD\xFFFF\x1\x7\x2\xFFFF\x1\x2\x12\xFFFF\x1\x6",
				"\x3\x5\x5\xFFFF\x1\x2\x3\xFFFF\x1\x2\x2\xFFFF\x1\x3\x1\x5\x2\xFFFF"+
				"\x1\x5\x5\xFFFF\x1\x2\xC\xFFFF\x1\x4",
				"",
				"\x3\x2\xD\xFFFF\x1\x7\x2\xFFFF\x1\x2\x12\xFFFF\x1\x6",
				"\x3\x9\x10\xFFFF\x1\x9\x12\xFFFF\x1\x8",
				"\x3\x9\x10\xFFFF\x1\x9\x12\xFFFF\x1\x8",
				""
			};

		private static readonly short[] DFA31_eot = DFA.UnpackEncodedString(DFA31_eotS);
		private static readonly short[] DFA31_eof = DFA.UnpackEncodedString(DFA31_eofS);
		private static readonly char[] DFA31_min = DFA.UnpackEncodedStringToUnsignedChars(DFA31_minS);
		private static readonly char[] DFA31_max = DFA.UnpackEncodedStringToUnsignedChars(DFA31_maxS);
		private static readonly short[] DFA31_accept = DFA.UnpackEncodedString(DFA31_acceptS);
		private static readonly short[] DFA31_special = DFA.UnpackEncodedString(DFA31_specialS);
		private static readonly short[][] DFA31_transition;

		static DFA31()
		{
			int numStates = DFA31_transitionS.Length;
			DFA31_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA31_transition[i] = DFA.UnpackEncodedString(DFA31_transitionS[i]);
			}
		}

		public DFA31( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 31;
			this.eot = DFA31_eot;
			this.eof = DFA31_eof;
			this.min = DFA31_min;
			this.max = DFA31_max;
			this.accept = DFA31_accept;
			this.special = DFA31_special;
			this.transition = DFA31_transition;
		}

		public override string Description { get { return "127:53: ( ( WS )+ ( ( MOVE_LABEL )? ( WS )* NO_MOVE ( WS )* )? individualMove )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _document_in_parse628 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compulsoryTag_in_parseTag638 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _optionalTag_in_parseTag642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _gameList_in_document651 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_document653 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _game_in_gameList662 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _optionalTag_in_generalTagList674 = new BitSet(new ulong[]{0x100000040002UL});
		public static readonly BitSet _compulsoryTag_in_generalTagList676 = new BitSet(new ulong[]{0x100000040002UL});
		public static readonly BitSet _WS_in_generalTagList680 = new BitSet(new ulong[]{0x100000040000UL});
		public static readonly BitSet _optionalTag_in_generalTagList684 = new BitSet(new ulong[]{0x100000040002UL});
		public static readonly BitSet _compulsoryTag_in_generalTagList686 = new BitSet(new ulong[]{0x100000040002UL});
		public static readonly BitSet _generalTagList_in_game698 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _WS_in_game700 = new BitSet(new ulong[]{0x100000204002UL});
		public static readonly BitSet _moveList_in_game704 = new BitSet(new ulong[]{0x100000004002UL});
		public static readonly BitSet _WS_in_game708 = new BitSet(new ulong[]{0x100000004002UL});
		public static readonly BitSet _GAME_RESULT_END_OF_MOVETEXT_in_game711 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _WS_in_game714 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _blockComment_in_annotation726 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variantLine_in_annotation730 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _annotation_in_annotationList739 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _WS_in_annotationList742 = new BitSet(new ulong[]{0x100000010020UL});
		public static readonly BitSet _annotation_in_annotationList745 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _set_in_individualMove757 = new BitSet(new ulong[]{0x100008100202UL});
		public static readonly BitSet _PROMOTES_TO_PIECE_in_individualMove773 = new BitSet(new ulong[]{0x100000100202UL});
		public static readonly BitSet _CHECK_in_individualMove780 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _MATE_in_individualMove784 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _WS_in_individualMove789 = new BitSet(new ulong[]{0x100000800000UL});
		public static readonly BitSet _NUMERIC_ANNOTATION_GLYPH_in_individualMove794 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _WS_in_individualMove799 = new BitSet(new ulong[]{0x100000010020UL});
		public static readonly BitSet _annotationList_in_individualMove802 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _move_in_moveList816 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _WS_in_moveList819 = new BitSet(new ulong[]{0x100000200000UL});
		public static readonly BitSet _move_in_moveList822 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _MOVE_LABEL_in_move833 = new BitSet(new ulong[]{0x1000024001C0UL});
		public static readonly BitSet _WS_in_move835 = new BitSet(new ulong[]{0x1000024001C0UL});
		public static readonly BitSet _NO_MOVE_in_move839 = new BitSet(new ulong[]{0x1000020001C0UL});
		public static readonly BitSet _WS_in_move841 = new BitSet(new ulong[]{0x1000020001C0UL});
		public static readonly BitSet _individualMove_in_move846 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _WS_in_move849 = new BitSet(new ulong[]{0x1000026001C0UL});
		public static readonly BitSet _MOVE_LABEL_in_move853 = new BitSet(new ulong[]{0x100000400000UL});
		public static readonly BitSet _WS_in_move856 = new BitSet(new ulong[]{0x100000400000UL});
		public static readonly BitSet _NO_MOVE_in_move859 = new BitSet(new ulong[]{0x1000020001C0UL});
		public static readonly BitSet _WS_in_move861 = new BitSet(new ulong[]{0x1000020001C0UL});
		public static readonly BitSet _individualMove_in_move866 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _eventTag_in_compulsoryTag877 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _siteTag_in_compulsoryTag881 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dateTag_in_compulsoryTag885 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _roundTag_in_compulsoryTag889 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blackTag_in_compulsoryTag893 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whiteTag_in_compulsoryTag897 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _resultTag_in_compulsoryTag901 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCK_COMMENT_in_blockComment913 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_BRACKET_in_enterVariant923 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RIGHT_BRACKET_in_leaveVariant933 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enterVariant_in_variantLine943 = new BitSet(new ulong[]{0x100080210000UL});
		public static readonly BitSet _moveList_in_variantLine946 = new BitSet(new ulong[]{0x100080210000UL});
		public static readonly BitSet _variantLine_in_variantLine950 = new BitSet(new ulong[]{0x100080210000UL});
		public static readonly BitSet _WS_in_variantLine954 = new BitSet(new ulong[]{0x100080000000UL});
		public static readonly BitSet _leaveVariant_in_variantLine957 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_eventTag967 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _EVENT_in_eventTag969 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _WS_in_eventTag971 = new BitSet(new ulong[]{0x100020000000UL});
		public static readonly BitSet _QUOTED_STRING_in_eventTag976 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RIGHT_TAG_in_eventTag978 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_siteTag989 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _SITE_in_siteTag991 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _WS_in_siteTag993 = new BitSet(new ulong[]{0x100020000000UL});
		public static readonly BitSet _QUOTED_STRING_in_siteTag998 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RIGHT_TAG_in_siteTag1000 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_dateTag1011 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _DATE_in_dateTag1013 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _WS_in_dateTag1015 = new BitSet(new ulong[]{0x100020000000UL});
		public static readonly BitSet _QUOTED_STRING_in_dateTag1020 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RIGHT_TAG_in_dateTag1022 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_roundTag1033 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _ROUND_in_roundTag1035 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _WS_in_roundTag1037 = new BitSet(new ulong[]{0x100020000000UL});
		public static readonly BitSet _QUOTED_STRING_in_roundTag1042 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RIGHT_TAG_in_roundTag1044 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_blackTag1055 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _BLACK_in_blackTag1058 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _WS_in_blackTag1060 = new BitSet(new ulong[]{0x100020000000UL});
		public static readonly BitSet _QUOTED_STRING_in_blackTag1065 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RIGHT_TAG_in_blackTag1067 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_whiteTag1078 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _WHITE_in_whiteTag1080 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _WS_in_whiteTag1082 = new BitSet(new ulong[]{0x100020000000UL});
		public static readonly BitSet _QUOTED_STRING_in_whiteTag1087 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RIGHT_TAG_in_whiteTag1089 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_resultTag1100 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _RESULT_in_resultTag1102 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _WS_in_resultTag1104 = new BitSet(new ulong[]{0x100000002000UL});
		public static readonly BitSet _GAME_RESULT_in_resultTag1109 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RIGHT_TAG_in_resultTag1111 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_TAG_in_optionalTag1121 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _TAG_NAME_in_optionalTag1125 = new BitSet(new ulong[]{0x104000000000UL});
		public static readonly BitSet _WS_in_optionalTag1128 = new BitSet(new ulong[]{0x100020000000UL});
		public static readonly BitSet _QUOTED_STRING_in_optionalTag1133 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RIGHT_TAG_in_optionalTag1135 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Redchess.Pgn 
